<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杰峰的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="wang-jie-feng.github.io/"/>
  <updated>2019-12-08T13:11:55.212Z</updated>
  <id>wang-jie-feng.github.io/</id>
  
  <author>
    <name>王杰峰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法题：插入区间</title>
    <link href="wang-jie-feng.github.io/2019/12/08/%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <id>wang-jie-feng.github.io/2019/12/08/插入区间/</id>
    <published>2019-12-08T13:03:05.277Z</published>
    <updated>2019-12-08T13:11:55.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><p>完成一道算法题，插入区间(InsertInstervals)</p><a id="more"></a>    <ol><li><p>题目简介</p><p>给出一个无重叠的 ，按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p></li><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newInterval == <span class="keyword">null</span> || interval[<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]) &#123;</span><br><span class="line">                result.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; newInterval[<span class="number">1</span>])&#123;</span><br><span class="line">                result.add(newInterval);</span><br><span class="line">                result.add(interval);</span><br><span class="line">                newInterval = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newInterval[<span class="number">0</span>] = Math.min(newInterval[<span class="number">0</span>],interval[<span class="number">0</span>]);</span><br><span class="line">                newInterval[<span class="number">1</span>] = Math.max(newInterval[<span class="number">1</span>],interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.add(newInterval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] out = <span class="keyword">new</span> <span class="keyword">int</span>[result.size()][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; out.length; i++) &#123;</span><br><span class="line">            out[i] = result.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>思路</p><p>首先将位于新数组之前的那些数组添加进去</p><p>然后比较并合并新旧数组</p><p>合并之后，如果之后还有数组，那么先将更新之后的新数组添加，然后添加当前数组并将新数组置为空</p><p>当新数组为空时，如果还有数组，那么和开始一样直接添加即可</p><p>如果合并之后没有数组了，那么只将更新之后的新数组添加即可</p><p>最后将其转化为二维数组，返回</p></li><li><p>思考：目前时间复杂度是log(n)可以使用二分法查找出左右两个元素位于数组位置，之后将其处理可将时间复杂度降为2log(n)</p></li></ol>]]></content>
    
    <summary type="html">
    
      算法题笔记，插入区间
    
    </summary>
    
    
    
      <category term="leetcode" scheme="wang-jie-feng.github.io/tags/leetcode/"/>
    
      <category term="算法" scheme="wang-jie-feng.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>jvm对象创建</title>
    <link href="wang-jie-feng.github.io/2019/11/28/jvm%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/"/>
    <id>wang-jie-feng.github.io/2019/11/28/jvm对象创建/</id>
    <published>2019-11-28T06:50:32.150Z</published>
    <updated>2019-11-28T06:51:57.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>jvm创建一个对象的流程</li></ol><a id="more"></a>    <h1 id="java创建对象过程"><a href="#java创建对象过程" class="headerlink" title="java创建对象过程"></a>java创建对象过程</h1><ol><li><p>类加载检查</p><p>虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过，解析和初始化过，如果没有那么必须先执行相应的类加载过程</p></li><li><p>分配内存</p><p>类加载通过后，接下来虚拟机将为新生对象分配内存，内存大小在类加载检查之后就可以获取得到，分配内存主要是将一块完整的内存从java堆中划分出来，分配方式有“指针碰撞”和“空闲列表”两种方式，选择哪种方式以java堆是否规整决定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</p><p>内存分配的两种方式</p><ol><li>指针碰撞：适用于堆内存规整的情况，用过的内存整合到一边，没用过的放到另一边，中间一个分界指针，只要向着没用过的内存方向移动对象内存大小即可，gc收集器 Serial，ParNew</li><li>空闲列表：适用于堆内存不规整的情况，虚拟机会维护一个列表记录哪些内存块是可用的，找一块足够大的内存块分配给对象实例，最后更新表的记录值，GC收集器 CMS</li></ol><p>内存分配并发问题（比较重要）</p><ol><li>CAS+失败重试：CAS是乐观锁的一种实现方式，乐观锁就是每次不加锁而去假设没有冲突而去完成某项操作，如果因为冲突失败就重试，知道成功为止，虚拟机采用CAS+失败重试是为了保证更新操作的原子性</li><li>TLAB：为每一个线程预先在Eden区分配一块内存，JVM再给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或是TLAB的内存已经用尽，再适用上述的CAS进行内存失败</li></ol></li><li><p>初始化零值</p><p>内存分配完成后，虚拟机需要将分配的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在java代码中可以不赋初值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值</p></li><li><p>设置对象头</p><p>初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 </p></li><li><p>执行init方法</p><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 </p></li></ol>]]></content>
    
    <summary type="html">
    
      jvm对象创建流程
    
    </summary>
    
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="wang-jie-feng.github.io/tags/java/"/>
    
      <category term="jvm" scheme="wang-jie-feng.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>OSI与TCP/IP各层简介</title>
    <link href="wang-jie-feng.github.io/2019/11/28/http%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>wang-jie-feng.github.io/2019/11/28/http基础知识/</id>
    <published>2019-11-28T06:31:13.542Z</published>
    <updated>2019-11-28T06:33:22.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OSI与TCP-IP各层简介"><a href="#OSI与TCP-IP各层简介" class="headerlink" title="OSI与TCP/IP各层简介"></a>OSI与TCP/IP各层简介</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>对于HTTP的一点学习笔记</li></ul><a id="more"></a><p><img src="http://101.132.149.94:50001/22a1d9a9-29c5-4577-8be8-f10707b74522.png" alt></p><p>学习计算机网络我们一般采用一个折中的方法，使用一种只有五层协议的体系结构，这样可以中和两者的优点，可以即简洁又能将概念阐述明白</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p> <strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。</strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。 </p><h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><p> 域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.xn--comoracle-xj3h/" target="_blank" rel="noopener">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.xn--comcisco-hm3g8360a63fhh376bwz2c1gzc/" target="_blank" rel="noopener">www.oracle.com、Cisco公司的域名是</a> <a href="http://www.cisco.com/" target="_blank" rel="noopener">www.cisco.com</a> 等。 </p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p> 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科） </p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p> <strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。 </p><h3 id="运输层主要使用以下两种协议"><a href="#运输层主要使用以下两种协议" class="headerlink" title="运输层主要使用以下两种协议:"></a><strong>运输层主要使用以下两种协议:</strong></h3><ol><li><strong>输控制协议 TCP</strong>（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。 </li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p> <strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。 </p><p> 互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。 </p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p> <strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 </p><p> 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。 </p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p> 在物理层上所传送的数据单位是比特。 <strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 </p><p> 在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。 </p><h2 id="面试常用题"><a href="#面试常用题" class="headerlink" title="面试常用题"></a>面试常用题</h2><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><ol><li><p>过程</p><ol><li>客户端发送带有SYN标志的数据包-&gt;服务端</li><li>服务端发送带有SYN/ACK标志的数据包-&gt;客户端</li><li>客户端发送带有ACK标志的数据包-&gt;服务端</li></ol></li><li><p>意义</p><p>通过三次握手可以建立可靠地通信信道，三次握手最主要的目的就是双方确认自己与对方的发送与接受是正常的</p></li><li><p>为什么要传回SYN</p><p>SYN信号是第一次握手时客户端发送过去的，是为了确定服务端接受到客户端的数据是正常的</p></li><li><p>ACK的意义</p><p>用于确认接收方到发送方的信道没有问题</p></li><li><p>四次挥手协议</p><p>断开tcp连接需要四次挥手</p><ol><li>客户端发送一个FIN，关闭到服务端的连接</li><li>服务端收到FIN发回一个ACK</li><li>服务端关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端发回ACK确认</li></ol><p>意义</p><p> 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。 </p></li></ol><h3 id="TCP-UDP协议的区别"><a href="#TCP-UDP协议的区别" class="headerlink" title="TCP/UDP协议的区别"></a>TCP/UDP协议的区别</h3><p> UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等 </p><p> TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。 </p><h3 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h3><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。 </li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 </li><li>TCP 的接收端会丢弃重复的数据。 </li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） </li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。 </li><li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 </li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </li></ol><h3 id="浏览器输入URL-gt-显示主页的过程"><a href="#浏览器输入URL-gt-显示主页的过程" class="headerlink" title="浏览器输入URL-&gt;显示主页的过程"></a>浏览器输入URL-&gt;显示主页的过程</h3><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p><img src="http://101.132.149.94:50001/4a2399b6-47dc-476e-96ed-80afce100a11.png" alt></p><h3 id="各种协议与HTTP协议之间的关系"><a href="#各种协议与HTTP协议之间的关系" class="headerlink" title="各种协议与HTTP协议之间的关系"></a>各种协议与HTTP协议之间的关系</h3><p><img src="http://101.132.149.94:50001/717ca879-51a8-4c2e-9ee0-c7dcf667e0cf.png" alt></p><h3 id="HTTP长连接，短连接"><a href="#HTTP长连接，短连接" class="headerlink" title="HTTP长连接，短连接"></a>HTTP长连接，短连接</h3><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 </p><p> 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 </p><p> <strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong> </p><h3 id="HTTP协议如何保存状态"><a href="#HTTP协议如何保存状态" class="headerlink" title="HTTP协议如何保存状态"></a>HTTP协议如何保存状态</h3><p>使用session来保存，可以将sessionId放在cookie里面</p><p>如果cookie禁用，可以使用url重写将sessionId追加在url后面</p><h3 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h3><p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。 </p><p><strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了 .</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h3 id="HTTP1-0和HTTP1-1的主要区别是什么"><a href="#HTTP1-0和HTTP1-1的主要区别是什么" class="headerlink" title="HTTP1.0和HTTP1.1的主要区别是什么"></a>HTTP1.0和HTTP1.1的主要区别是什么</h3><ol><li><strong>长连接</strong> : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 <strong>HTTP/1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。 </li><li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 </li><li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 </li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 </li></ol><h3 id="URI和URL的区别是什么"><a href="#URI和URL的区别是什么" class="headerlink" title="URI和URL的区别是什么"></a>URI和URL的区别是什么</h3><ol><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。 </li><li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。 </li></ol><p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。 </p><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ol><li><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。 </li><li><strong>安全性和资源消耗：</strong> HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。<ol><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等 </li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。 </li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      OSI与TCP/IP各层简介
    
    </summary>
    
    
      <category term="HTTP" scheme="wang-jie-feng.github.io/categories/HTTP/"/>
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="HTTP" scheme="wang-jie-feng.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>netty组件和设计</title>
    <link href="wang-jie-feng.github.io/2019/11/25/netty%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    <id>wang-jie-feng.github.io/2019/11/25/netty组件设计/</id>
    <published>2019-11-25T06:46:33.164Z</published>
    <updated>2019-11-25T06:46:21.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>上一篇写了一个小的demo，之后继续学习netty</li><li>主要看了一些netty的组件及设计</li></ol><a id="more"></a>    <h2 id="netty组件和设计"><a href="#netty组件和设计" class="headerlink" title="netty组件和设计"></a>netty组件和设计</h2><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ol><li>Channel - Socket</li><li>原生的java网络编程依赖于socket来实现，Channel通过封装其并对其添加了许多的API，大大降低了使用Socket的复杂性，并且拥有许多预定义的，专门化实现的广泛类层结构的根<ol><li>EmbeddedChannel</li><li>LocalServerChannel</li><li>NioDatagramChannel</li><li>NioSctpChannel</li><li>NioSocketChannel</li></ol></li></ol><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><ol><li>EventLoop定义了Netty的核心抽象，用于处理连接的生命周期中所发生的事情</li></ol><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><ol><li>由于Netty所有的I/O操作都是异步的，所以我们需要一个方法可以用于在某个时间点确定其结果的</li><li>可是使得某个操作完成后（无论是否成功）得到通知</li></ol><h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><ol><li>从应用开发人员的角度来看，Netty的主要组件是ChannelHandler，它充当了所有处理入站和出站数据的应用程序逻辑的容器</li><li>ChannelHandler的方法是用网络事件触发的，可以用于几乎所有类型的动作，例如将一种格式转换为另一种格式，或者处理转换过程中的异常</li></ol><h3 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h3><ol><li>handler是处理数据的应用程序的容器，那么Pipeline就是Handler链的容器，并定义了用于在该链上传播入站和出站事件流的API，当Channel被创建时，他会被自动得分配到它专属的ChannelPipeline</li><li>可以使用ChannelInitializer中的initChannel()方法安装一组自定义的ChannelHandler</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>开始的时候看这些非常的抽象，但是如果多读几遍，还是非常有理解的，其实不外乎外界请求入站出站，然后在中间进行一些数据处理，异常处理，同时这些还是多线程处理的，多看几遍多一些自己的理解，重要的还是使用其实现一些功能，写一些代码，那样会有更深刻的理解</p>]]></content>
    
    <summary type="html">
    
      写了一个小demo之后，进行netty的组件和设计的学习
    
    </summary>
    
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="netty" scheme="wang-jie-feng.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty入门笔记</title>
    <link href="wang-jie-feng.github.io/2019/11/25/netty%E5%85%A5%E9%97%A8/"/>
    <id>wang-jie-feng.github.io/2019/11/25/netty入门/</id>
    <published>2019-11-25T06:20:28.412Z</published>
    <updated>2019-11-25T06:20:12.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>看了netty实战这本书，记一些自己的笔记，希望自己可以进步</li></ol><a id="more"></a>    <h2 id="netty入门程序"><a href="#netty入门程序" class="headerlink" title="netty入门程序"></a>netty入门程序</h2><ol><li><p>理解一个框架最好的办法还是去使用他，使用之后肯定可以对其有了更多的理解，所以首先写一个小的demo，来看一看具体是怎么使用的</p></li><li><p>首先来写一个时间服务器，分为客户端和服务端，客户端发送一个请求，服务器端接收到请求之后返回一个时间数据，客户端将其打印出来</p></li><li><p>服务器端代码</p><p>服务器端主函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fire;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TimeServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//        用来调度，所以只需要一个</span></span><br><span class="line"><span class="comment">//        不可混用不同前缀的组件</span></span><br><span class="line">        EventLoopGroup bossGroup=<span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup=<span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b=<span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup,workerGroup)</span><br><span class="line"><span class="comment">//                    在此指定了网络响应的方式，可以使用阻塞式的也可以使用非阻塞式的</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//                            在此可以添加多个适配器，netty自己会识别是出站或是入栈适配器，确保数据只会在具有相同定向类型的适配器之间流动</span></span><br><span class="line"><span class="comment">//                            同时每个channel在创建时，会被分配一个pipiline，不可以附加另外的，也不可以分离当前的</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> TimeServerHandler());</span><br><span class="line"><span class="comment">//                            使用eventLoop的线程调度来实现自己的任务</span></span><br><span class="line">                            ch.eventLoop().scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                    System.out.println(<span class="string">"自定义任务"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;,<span class="number">10</span>,<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                            System.out.println(ch.pipeline().names());</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> TimeServer(<span class="number">9090</span>).run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fire;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.ReferenceCountUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现时间服务器具体逻辑代码</span></span><br><span class="line"><span class="comment"> * 实现的入栈适配器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次新的请求来之后，都会进行相应，ctx使得handler可以和pipeline以及其他的handler交互</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        获得一个buffer用于存储网络传输的数据，初始化最大为4，返回的是一个基于堆或者是基于直接内存的</span></span><br><span class="line"><span class="comment">//        如果当前运行的环境具有sun.misc.Unsafe支持时返回的是一个基于直接内存的，否则返回的是基于堆内存的</span></span><br><span class="line"><span class="comment">//        默认使用的api是基于池化的，所以返回的是一个引用，并不是返回的一个实例</span></span><br><span class="line"><span class="comment">//        可以使用Unpooled来获取非池化的实例，但是基于池化的性能比较强，所以一般还是使用默认的</span></span><br><span class="line">        ByteBuf time = ctx.alloc().buffer(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//        将时间写入 buffer中</span></span><br><span class="line">        time.writeInt((<span class="keyword">int</span>)(System.currentTimeMillis()/<span class="number">1000L</span>+<span class="number">2208988800L</span>));</span><br><span class="line"><span class="comment">//        将时间写入输出流，并冲刷出去，由于异步操作，此时并没有真正发送出去</span></span><br><span class="line">        ChannelFuture f = ctx.writeAndFlush(time);</span><br><span class="line"><span class="comment">//        使用future的close回调,如果成功发送，那么关闭</span></span><br><span class="line">        f.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        首先输出堆栈信息，之后关闭ctx</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    此方法为已经注册且能处理io操作时被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelRegistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    被注销且无法处理io操作时被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelUnregistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    离开活动状态，且不再连接他的远程节点时被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelInactive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    当从channel读取数据时被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        msg在此被处理，如果msg被消费或者丢弃了，那么开发者有责任将其释放资源</span></span><br><span class="line"><span class="comment">//        netty在此提供了一个简单的方法释放资源，如下代码，可以简便的释放资源</span></span><br><span class="line"><span class="comment">//        ReferenceCountUtil.release(msg);</span></span><br><span class="line">        <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    当所有可读的字节都已经从channel中读取之后，将会调用该回调方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelReadComplete(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    传入一个pojo类是被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelWritabilityChanged(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端代码</p><p>客户端主函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fire;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Bootstrap客户端用于简单建立Channel</span></span><br><span class="line">            <span class="comment">//childOption不能用于Bootstrap</span></span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(workerGroup);</span><br><span class="line">            <span class="comment">//NioSocketChannel用于客户端创建Channel</span></span><br><span class="line">            b.channel(NioSocketChannel.class);</span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">            b.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">//指定使用的数据处理方式</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> TimeClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//客户端开始连接</span></span><br><span class="line">            ChannelFuture f = b.connect(<span class="string">"localhost"</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            <span class="comment">//等待直到这个连接被关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   客户端handler</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fire;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf m=(ByteBuf)msg;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//m.readUnsignedInt获取ByteBuf当中无符号的32-bit的integer</span></span><br><span class="line">            <span class="comment">//就是我们writeInt的那个时间</span></span><br><span class="line"><span class="comment">//            获取到的是秒数，所以直接按照int读，之后自己转化为时间</span></span><br><span class="line">            <span class="keyword">long</span> currentTimeMillis = (m.readUnsignedInt() - <span class="number">2208988800L</span>) * <span class="number">1000L</span>;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date(currentTimeMillis));</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            m.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>handler是netty实现业务逻辑的地方，在此可以实现一些我们想要实现的逻辑</li></ol>]]></content>
    
    <summary type="html">
    
      对于netty的一个入门的小demo
    
    </summary>
    
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="netty" scheme="wang-jie-feng.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>git提交</title>
    <link href="wang-jie-feng.github.io/2019/11/19/git%E5%85%B3%E8%81%94%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>wang-jie-feng.github.io/2019/11/19/git关联到远程仓库/</id>
    <published>2019-11-19T07:22:14.759Z</published>
    <updated>2019-11-19T07:30:09.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>使用git时候一些小的经验</li></ul><a id="more"></a>    <h1 id="将本地工程关联到远程仓库"><a href="#将本地工程关联到远程仓库" class="headerlink" title="将本地工程关联到远程仓库"></a>将本地工程关联到远程仓库</h1><ul><li>其实非常简单，当你在github创建仓库之后就已经给了提示</li><li>步骤<ol><li>初始化本地工程 git init</li><li>将本地工程添加到暂存区 git add .</li><li>提交到本地仓库 git commit -m “first commit”</li><li>关联到远程仓库 git remote add origin  仓库地址</li><li>推送 git push -u origin master 第一次提交的时候需要加上-u参数</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      git学习笔记
    
    </summary>
    
    
    
      <category term="git" scheme="wang-jie-feng.github.io/tags/git/"/>
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>简历</title>
    <link href="wang-jie-feng.github.io/2019/11/14/%E7%8E%8B%E6%9D%B0%E5%B3%B0%E7%AE%80%E5%8E%86/"/>
    <id>wang-jie-feng.github.io/2019/11/14/王杰峰简历/</id>
    <published>2019-11-14T03:49:23.716Z</published>
    <updated>2019-11-19T07:31:37.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul><li>Email：<a href="mailto:jiefengfire@163.com" target="_blank" rel="noopener">jiefengfire@163.com</a> </li><li>手机：15518955832</li></ul><hr><a id="more"></a>    <h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li><p>王杰峰/男/1998</p></li><li><p>本科/南阳理工学院/计算机系/物联网专业</p></li><li><p>技术博客：<a href="http://wang-jie-feng.github.io">http://wang-jie-feng.github.io</a></p></li><li><p>Github： <a href="https://github.com/wang-jie-feng" target="_blank" rel="noopener">https://github.com/wang-jie-feng</a> </p></li><li><p>期望职位：Java开发工程师实习生</p></li><li><p>期望薪资：实习4-6k</p></li><li><p>期望城市：上海</p></li></ul><hr><h1 id="参与项目"><a href="#参与项目" class="headerlink" title="参与项目"></a>参与项目</h1><h2 id="javaWeb商城项目"><a href="#javaWeb商城项目" class="headerlink" title="javaWeb商城项目"></a>javaWeb商城项目</h2><ul><li>开发环境：jdk1.8/Tomcat7.0/MySql5.5/IDEA</li><li>技术架构：基于Servlet、JSP、Ajax进行开发</li><li>项目描述：系统主要实现了用户注册，登陆，退出，邮件激活账号，导航栏数据，分页查询，模糊查询，订单详情，购物车，支付宝支付，宝贝收藏等功能</li></ul><h2 id="SpringBoot项目"><a href="#SpringBoot项目" class="headerlink" title="SpringBoot项目"></a>SpringBoot项目</h2><ul><li>开发环境：jdk1.8/Tomcat7.0/maven3.5/springBoot/nginx</li><li>技术架构：基于springBoot实现</li><li>项目描述：项目开放了两个接口<ul><li>传入文件，返回访问地址</li><li>传入文件，返回md格式的图片链接</li></ul></li></ul><h2 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h2><ul><li>使用<code>Jenkins</code>结合<code>github</code>自动化部署应用</li><li>编码 → 构建 → 集成 → 测试 → 交付 → 部署 </li><li>编写脚本结合<code>Jenkins</code>实现从代码到<code>docker</code>的持续交付部署</li><li>实现过程地址： <a href="https://www.wangjiefeng.cn/2019/10/29/jendins测试/#more" target="_blank" rel="noopener">https://www.wangjiefeng.cn/2019/10/29/jendins%E6%B5%8B%E8%AF%95/#more</a> </li></ul><h2 id="目前在做-未完成…"><a href="#目前在做-未完成…" class="headerlink" title="目前在做(未完成…)"></a>目前在做(未完成…)</h2><ul><li>简介<ul><li>文件上传下载，实现文件的上传与下载</li></ul></li><li>难点<ol><li>使用对称加密与非对称加密结合方式</li><li>使用java自带数据库<code>derby</code>，使用<code>jdbc</code>原生开发</li><li>服务端使用原生<code>Servlet</code>+<code>Tomcat</code>开发,客户端使用springBoot开发</li><li>安全认证：客户端私钥签名，服务端公钥验签</li></ol></li><li>功能介绍<ol><li>文件上传服务端之后使用<code>AES</code>加密，将密钥石笋<code>RSA</code>公钥加密存储数据库中</li><li>客户端获取加密文件与加密之后的秘钥，使用<code>RSA</code>私钥解密，获取密钥将文件解密</li></ol></li></ul><hr><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><p>以下均为我熟练使用的技能</p><ul><li>Web开发：<code>java</code></li><li>Web框架：SSM/springBoot/springCloud/</li><li>前端框架：Vue</li><li>开发工具：idea/PostMan/webStorm</li><li>数据库相关：MySQL/PLSql/Oracle</li><li>版本管理、文档和自动化部署工具：Svn/Git/Jenkins</li><li>单元测试：Junit/Mock</li></ul><h1 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h1><ol><li>喜欢学习新技术，并使用它创造更好的东西</li><li>抗压能力强</li><li>完成任务效率较高</li></ol><hr><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢您花时间阅读我的简历， 期待能够得到同您面谈/面试的机会 。</p>]]></content>
    
    <summary type="html">
    
      一个进步中的java程序员，如果有工作岗位，可以联系网
    
    </summary>
    
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="简历" scheme="wang-jie-feng.github.io/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>tomcat使用笔记</title>
    <link href="wang-jie-feng.github.io/2019/11/13/%E8%A7%A3%E5%86%B3tomcat%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>wang-jie-feng.github.io/2019/11/13/解决tomcat控制台乱码问题/</id>
    <published>2019-11-13T01:45:13.859Z</published>
    <updated>2019-11-13T01:51:50.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>解决使用tomcat时，控制台输出乱码问题</p><a id="more"></a>    <ol><li><p>找到<code>apache-tomcat-8.5.46\conf\logging.properties</code></p></li><li><p>如图</p><p><img src="http://101.132.149.94:50001/33937eba-06a5-4173-887b-66a00b83331c.jpg" alt=""></p></li><li><p>将图上的UTF-8改为GBK即可</p></li></ol>]]></content>
    
    <summary type="html">
    
      解决了tomcat控制台输出乱码问题
    
    </summary>
    
    
      <category term="tomcat" scheme="wang-jie-feng.github.io/categories/tomcat/"/>
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="tomcat" scheme="wang-jie-feng.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>编程六大原则</title>
    <link href="wang-jie-feng.github.io/2019/10/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>wang-jie-feng.github.io/2019/10/31/设计模式六大原则/</id>
    <published>2019-10-31T06:15:12.684Z</published>
    <updated>2019-10-31T07:28:34.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>对于编程时六大原则的理解</li></ul><a id="more"></a>    <h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>六大原则</p><ol><li>单一职责原则(Single Responsibility Principle)</li><li>里氏替换原则(liskov substitution principle)</li><li>依赖倒置原则(dependence inversion principle)</li><li>接口隔离原则(interface segregation principle)</li><li>迪米特原则(law of demeter)</li><li>开闭原则(open closed principle)</li></ol><p>接下来就这六大原则写一些关于自己的看法</p><h3 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(Single Responsibility Principle)"></a>单一职责原则(Single Responsibility Principle)</h3><p>应该有且仅有一个原因引起类的变更（There should never be more than one reason for a class to change）。</p><p>为了达到这个目标，我们需要对于类和业务逻辑进行拆分，划分到合适的粒度， 让这些各自执行单一职责的类，各司其职。让每个类尽量行使单一的功能，实现“高内聚”，这个结果也使得类和类之间不会有过多冗余的联系，从而“低耦合”</p><p>代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">driver</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playBasketball</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打篮球"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"游泳"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个类就有一点混乱，因为这一个类里边混杂了三个职责</p><ul><li>开车：这是司机应该做的</li><li>打篮球：这是篮球运动员该做的</li><li>游泳：这是游泳运动员该做的</li></ul><p>那么，如果要遵守单一职责原则，应该怎么做呢？我们需要根据接口拆分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 司机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">driver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 篮球运动员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasketballPplayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playBasketball</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 游泳运动员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Swimmer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在People中继承这几个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Driver</span>,<span class="title">BasketballPplayer</span>,<span class="title">Swimmer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">driver</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playBasketball</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打篮球"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"游泳"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了单一职责原则，但是原则不是死的，需要在实际开发中灵活运用，允许有一定冗余。</p><h3 id="里氏替换原则-liskov-substitution-principle"><a href="#里氏替换原则-liskov-substitution-principle" class="headerlink" title="里氏替换原则(liskov substitution principle)"></a>里氏替换原则(liskov substitution principle)</h3><p> 所有引用基类的地方必须能透明地使用其子类的对象。 </p><p>换句可以更好理解的话说，就是子类必须完全实现父类的功能，凡是父类出现的地方，就算替换成子类也不会有什么问题。</p><p>标准的反例就是，如果你继承了一个类，之后你实现了类中的一个方法，可是里边什么具体代码也不写，那么就违反了里氏替换原则。这里表面上子类实现了父类的方法，但是并没有实现父类要求的逻辑。需要在代码中尽量避免这种情况。</p><p>例子</p><p>父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 认真工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 实现了父类的work方法，但是什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖倒置原则-dependence-inversion-principle"><a href="#依赖倒置原则-dependence-inversion-principle" class="headerlink" title="依赖倒置原则(dependence inversion principle)"></a>依赖倒置原则(dependence inversion principle)</h3><p>一般来说都会有三个方面来阐述</p><ul><li>高层的模块不应该依赖于低层的模块，这两者都应该依赖于其抽象</li><li>抽象不应该依赖于细节</li><li>细节应该依赖与抽象</li></ul><p>换句话说，高层次的类不应该依赖于或者说耦合与低层次的类，相反这两者都需要通过相关的接口去实现，而不是面向实现编程，所以编程的时候并不是按照我们逻辑思维思考的“依赖关系”去编程的，所以叫做依赖倒置。</p><p>改造前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层模块1:开发者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">develop</span> <span class="params">(Linux linux)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"开发者正在%s系统上进行开发%n"</span>,linux.getSystemName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 底层模块2:Linux操作系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Linux</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Linux</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSystemName</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高层模块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args [])</span> </span>&#123;</span><br><span class="line">        Coder coder = <span class="keyword">new</span> Coder();</span><br><span class="line">        Linux ubuntu = <span class="keyword">new</span> Linux(<span class="string">"ubuntu系统"</span>); </span><br><span class="line">        coder.develop(ubuntu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序员接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Programmer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">develop</span> <span class="params">(OperatingSystem OS)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 操作系统接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OperatingSystem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSystemName</span> <span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 低层模块：Linux操作系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Linux</span> <span class="keyword">implements</span>  <span class="title">OperatingSystem</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Linux</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSystemName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 低层模块：Window操作系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">OperatingSystem</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Window</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSystemName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 低层模块：开发者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> <span class="keyword">implements</span> <span class="title">Programmer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">develop</span><span class="params">(OperatingSystem OS)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"开发者正在%s系统上进行开发%n"</span>,OS.getSystemName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高层模块：测试用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args [])</span> </span>&#123;</span><br><span class="line">        Programmer coder = <span class="keyword">new</span> Coder();</span><br><span class="line">        OperatingSystem ubuntu = <span class="keyword">new</span> Linux(<span class="string">"ubuntu系统"</span>); <span class="comment">// ubuntu是一种linux操作系统</span></span><br><span class="line">        OperatingSystem windows10 = <span class="keyword">new</span> Window(<span class="string">"windows10系统"</span>); <span class="comment">// windows10</span></span><br><span class="line">        coder.develop(ubuntu);</span><br><span class="line">        coder.develop(windows10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，改造之后，虽然代码多了一些，但是可扩展性增加了非常多，即是有新的需求加入，也可以处理</p><h3 id="接口隔离原则-interface-segregation-principle"><a href="#接口隔离原则-interface-segregation-principle" class="headerlink" title="接口隔离原则(interface segregation principle)"></a>接口隔离原则(interface segregation principle)</h3><p>接口隔离的要求是：类之间的依赖关系应该建立在最小的接口上，主要分为了两点</p><ul><li>接口要足够细化，当然了，这会让接口的数量变多，但是每个接口会具有更加明确的功能 </li><li>在1的前提下，类应该依赖于“最小”的接口上 </li></ul><p>比如，现在有一大袋子吃的，但是全拿起来你是拿不动的，这时候我们就可以从里边将我们喜欢吃的拿出来，这样既满足了我们的需要，可以带走非常轻巧</p><p>备注：其实有时候单一职责原则和接口隔离原则是会互相冲突的，单一职责希望我们划分的粒度正好合适，不能多也不能少，接口隔离原则希望我们将粒度划分的尽可能小，如果出现这种情况，优先遵循单一职责原则</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 努力工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">workHard</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 消极工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NegativeWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们只想要努力工作这个需求，所以我们可以将这接口细分一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GoodWorker</span></span>&#123;</span><br><span class="line">    <span class="comment">//努力工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">workHard</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BadWorker</span></span>&#123;</span><br><span class="line">    <span class="comment">// 消极工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NegativeWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时就可以划分一个合理的范围</p><h3 id="迪米特原则-law-of-demeter"><a href="#迪米特原则-law-of-demeter" class="headerlink" title="迪米特原则(law of demeter)"></a>迪米特原则(law of demeter)</h3><p>迪米特原则还有一个名字叫做“少知道原则”，一个对象接触到的其他对象应该尽可能少，也即类和类之间的耦合度要低。</p><p>具体原则是</p><ul><li>一个类只和朋友类交流，朋友类指的是出现在成员变量、方法的输入输出参数中的类 </li><li>一个类不和陌生类交流，即没有出现在成员变量、方法的输入输出参数中的类 </li></ul><h3 id="开闭原则-open-closed-principle"><a href="#开闭原则-open-closed-principle" class="headerlink" title="开闭原则(open closed principle)"></a>开闭原则(open closed principle)</h3><p>开闭原则的意思是，软件架构要：对修改封闭，对扩展开放</p><p>比如我们使用一个软件，本来有一套我们已经使用的非常熟练的快捷键，用起来非常舒服，一天软件更新了，增加了一个快捷键实现了一个非常棒的功能，那么我们肯定非常开心</p><p>这就是增加了扩展，即对扩展开放</p><p>但是如果一次更新之后所有的快捷键都换位了，那么我们就直接抓狂了</p><p>所以我们希望已有的结构不要动，也不能动这就是“对修改封闭”</p>]]></content>
    
    <summary type="html">
    
      对于编程的六大原则的学习，探索
    
    </summary>
    
    
      <category term="六大原则" scheme="wang-jie-feng.github.io/categories/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="java" scheme="wang-jie-feng.github.io/tags/java/"/>
    
      <category term="编程" scheme="wang-jie-feng.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="六大原则" scheme="wang-jie-feng.github.io/tags/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>jenkins的测试</title>
    <link href="wang-jie-feng.github.io/2019/10/29/jendins%E6%B5%8B%E8%AF%95/"/>
    <id>wang-jie-feng.github.io/2019/10/29/jendins测试/</id>
    <published>2019-10-29T02:45:59.837Z</published>
    <updated>2019-10-29T09:31:35.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>jenkins在上一个帖子里边安装好了，那么肯定需要测试一下了，所以用一个小demo来测试一下如何使用</li></ul><a id="more"></a>    <h2 id="配置免密登陆"><a href="#配置免密登陆" class="headerlink" title="配置免密登陆"></a>配置免密登陆</h2><p>首先我们需要从使用git拉取代码，所以我们需要先配置一下ssh的免密登陆，这个需要之前安装好那个插件，如果之前没有安装那么可以现在安装一下</p><p>配置ssh密钥和和使用Git配置ssh密钥的时候没有什么差别</p><ol><li><p>进入docker运行bash</p><p><code>docker exec -id jenkins /bin/bash</code></p></li><li><p>生成ssh密钥</p><p><code>ssh-keygen -t rsa -C &quot;your_name@example.com&quot;</code></p></li><li><p>查看公钥</p><p><code>cat /var/jenkins_home/.ssh/id_rsa.pub</code></p></li><li><p>查看之后就直接将其复制然后添加到你的github里边就可以了</p></li><li><p>之后要先clone一个项目，获取到<code>known_hosts</code>文件</p></li></ol><h2 id="配置远程部署的主机"><a href="#配置远程部署的主机" class="headerlink" title="配置远程部署的主机"></a>配置远程部署的主机</h2><p><code>系统管理--&gt;系统设置--&gt;Publish over SSH</code></p><ol><li><p>点击新增填入，打了马赛克的都得填</p><p><img src="http://101.132.149.94:50001/313e04a6-c3c3-4984-822e-9b9d8cacfde3.jpg" alt=""></p></li><li><p>最后右下角的测试，测试一下是否可以连接</p></li><li><p>保存</p></li></ol><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><h3 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h3><ol><li><p>创建一个maven项目</p><p><img src="http://101.132.149.94:50001/a1b3c872-4a8f-476f-91fd-c0cb4bcd6b37.jpg" alt=""></p></li><li><p>构建项目</p><p><img src="http://101.132.149.94:50001/fb9a0916-201d-4b35-8737-ae6a89ff99ee.jpg" alt=""></p><p><img src="http://101.132.149.94:50001/6ade5114-5eb3-4588-a3d5-483f2aba860b.jpg" alt=""></p></li></ol><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p><img src="http://101.132.149.94:50001/c11701bc-e651-49b9-8c29-768a1f04cce5.jpg" alt=""></p><p><img src="http://101.132.149.94:50001/5799a39e-9ad8-415a-bfdf-6c6613fe1174.jpg" alt=""></p><p>经过这些步骤，jenkins会将代码构建到docker的工作空间里去所以我们应该加一个构建后操作，</p><p><img src="http://101.132.149.94:50001/f2f7b0aa-aa5c-4b6c-99d8-a985a346f813.jpg" alt=""></p><p>如果，这样就会将打包好的应用部署到目标服务器上</p>]]></content>
    
    <summary type="html">
    
      jenkins安装之后，测试一下
    
    </summary>
    
    
      <category term="jenkins" scheme="wang-jie-feng.github.io/categories/jenkins/"/>
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="docker" scheme="wang-jie-feng.github.io/tags/docker/"/>
    
      <category term="jenkins" scheme="wang-jie-feng.github.io/tags/jenkins/"/>
    
      <category term="测试" scheme="wang-jie-feng.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>图床服务器搭建</title>
    <link href="wang-jie-feng.github.io/2019/10/28/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/"/>
    <id>wang-jie-feng.github.io/2019/10/28/搭建自己的图床/</id>
    <published>2019-10-28T10:32:44.455Z</published>
    <updated>2019-10-29T02:44:11.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>图床就是放置图片的地方，对于使用hexo等搭建的静态页面博客来说，一个图床必不可少，但是对于开发者来说，市面上的图床很多存在各种限制，用起来不是很舒服，所以搭建一个自己的图床还是必不可少的</li><li>搭建一个图床并没有想象中的那么困难，而且可以锻炼自己的能力，一举多得</li></ul><a id="more"></a>    <h2 id="安装前的准备"><a href="#安装前的准备" class="headerlink" title="安装前的准备"></a>安装前的准备</h2><ol><li>一台阿里云服务器</li><li>需要安装的软件<ol><li>nginx</li></ol></li></ol><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>首先需要安装nginx，在此nginx的作用是对于图片资源的映射，使我们可以直接访问到图片资源</p><h4 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h4><ol><li><p>添加源，</p><p>默认情况下Centos7中并没有nginx的源，但是nginx提供了可以供centos7使用的源，所以可以添加一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure></li><li><p>安装nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure></li><li><p>启动nginx并设置开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx.service</span><br><span class="line">sudo systemctl enable nginx.service</span><br></pre></td></tr></table></figure></li><li><p>在浏览器中输入你的服务器地址，即可看到此图片，则安装成功</p><p><img src="http://101.132.149.94:50001/9733ad1c-336d-4c8f-8cf9-d53cce38bbb5.jpg" alt=""></p></li></ol><h4 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h4><p>安装完成之后需要配置一下，设置图片文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"># 设置监听的端口号</span><br><span class="line">        listen       50001;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"># 设置正则，配置以图片路径</span><br><span class="line">        location ~ \.(gif|jpg|jpeg|png|bmp|swf)$ &#123;</span><br><span class="line">            root /usr/local/images;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在这里使用的是50001端口，使用阿里云服务器的话，切记需要将阿里云控制台里边安全策略里边开放此端口，设置完成之后可以往里边放一个图片测试一下。</p><h2 id="Java代码部分"><a href="#Java代码部分" class="headerlink" title="Java代码部分"></a>Java代码部分</h2><p>使用nginx做完静态资源代理之后，需要写一个接口来实现图片上传并返回图片路径操作</p><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><p>待续，等我有空了在写哈哈哈哈哈哈哈哈</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>为了方便，我直接打包好了之后将jar包上传到了服务器上</p><p>使用<code>nohup java -jar fileName.jar &gt;temp.log&amp;</code>，将会以守护进程运行，temp.log将会在当前文件夹下输出日志 &gt;是覆盖式增加</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>使用postman进行调试，可以正常返回文件路径，完美</p><p><img src="http://101.132.149.94:50001/d573d5fd-134a-410a-89a4-6891d05c15c4.jpg" alt=""></p><h3 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h3><p>最好可以有一个前端页面，这样可以更好使用一些，体验更好一些…</p>]]></content>
    
    <summary type="html">
    
      使用阿里云来搭建自己的图床服务器
    
    </summary>
    
    
      <category term="图床" scheme="wang-jie-feng.github.io/categories/%E5%9B%BE%E5%BA%8A/"/>
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="nginx" scheme="wang-jie-feng.github.io/tags/nginx/"/>
    
      <category term="阿里云" scheme="wang-jie-feng.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="springboot" scheme="wang-jie-feng.github.io/tags/springboot/"/>
    
      <category term="java" scheme="wang-jie-feng.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>jenkins的安装</title>
    <link href="wang-jie-feng.github.io/2019/10/28/jendins%E5%AE%89%E8%A3%85/"/>
    <id>wang-jie-feng.github.io/2019/10/28/jendins安装/</id>
    <published>2019-10-28T06:21:34.477Z</published>
    <updated>2019-10-29T02:40:56.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>jenkins是一个个简单易用的持续集成平台，在此我使用docker的方式部署</li><li>需要主机安装docker和dockercompose，之前有可以参考一下</li></ul><a id="more"></a>    <h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><ol><li><p>docker配置文件，<code>docker-compose.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  jenkins:</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">jenkinsci/jenkins</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">jenkins</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line">      <span class="comment"># 发布端口</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">      <span class="comment"># 基于 JNLP 的 Jenkins 代理通过 TCP 端口 50000 与 Jenkins master 进行通信</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">50000</span><span class="string">:50000</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="comment"># 映射目录</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./data:/var/jenkins_home</span></span><br></pre></td></tr></table></figure></li><li><p>在和配置文件相同的文件夹下，使用<code>docker-compose up -d</code>,默认使用<code>docker-compose.yml</code></p></li><li><p>安装完成之后使用<code>docker logs jenkins</code>可获得初始密码</p></li></ol><h3 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h3><ol><li><p>打开<code>ip:8080</code>,进入jenkins控制台开始安装，在此选择<code>select plugins to install</code>，注意记得选择<code>user management and security</code>下的<code>Publish Over SSH</code></p><p><img src="http://101.132.149.94:50001/a6aac73f-ab2a-4928-8b70-3d53db518241.jpg" alt=""></p></li><li><p>点击安装，安装过程可能比较长，视个人网络环境和电脑配置而定，可以耐心等待一会，当时我安装的时候等了半个多小时还在安装，所以一定要有耐心。</p><p><img src="http://101.132.149.94:50001/a1720880-a5cc-4e17-b47c-3d8e3742130b.jpg" alt=""></p></li><li><p>有些插件可能安装失败，不过不用担心，可以之后手动安装。</p></li></ol><h3 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h3><ol><li>安装成功之后需要创建第一个管理员用户，按照提示完成即可</li></ol><h3 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>首先将jdk和maven的安装包上传到data目录里边，这是jenkins容器映射的目录，然后进入容器<code>docker exec -it jenkins /bin/bash</code>,进入<code>/var/jenkins_home</code>目录，记录下jdk和maven目录</p><ol><li><p>配置jdk</p><p>如图</p><p><img src="http://101.132.149.94:50001/b8e026a9-5b96-41bd-a4da-c4dfde871215.jpg" alt=""></p></li><li><p>配置maven</p><p>如图</p><p><img src="http://101.132.149.94:50001/585cc0b1-8870-4c76-991c-2ba68ecd18e1.jpg" alt=""></p></li><li><p>安装动态参数插件</p><p><code>系统管理--&gt;插件管理--&gt;可选插件--&gt;</code></p><p><img src="http://101.132.149.94:50001/6042783b-211c-4fb2-9f12-9a9bfd5f5dc9.jpg" alt=""></p></li><li><p>之后需要重启docker</p><p><code>docker-compose down</code></p><p><code>docker -compose up -d</code></p><p>安装成功</p><p><img src="http://101.132.149.94:50001/cf6ecc12-2d02-4595-9315-1b7673a78502.jpg" alt=""></p></li></ol><h3 id="安装结束"><a href="#安装结束" class="headerlink" title="安装结束"></a>安装结束</h3><pre><code>至此，差不多安装结束了，可以直接使用了</code></pre>]]></content>
    
    <summary type="html">
    
      jenkins的安装笔记
    
    </summary>
    
    
      <category term="jenkins" scheme="wang-jie-feng.github.io/categories/jenkins/"/>
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="docker" scheme="wang-jie-feng.github.io/tags/docker/"/>
    
      <category term="jenkins" scheme="wang-jie-feng.github.io/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose的安装</title>
    <link href="wang-jie-feng.github.io/2019/10/28/docker-compose%E5%AE%89%E8%A3%85/"/>
    <id>wang-jie-feng.github.io/2019/10/28/docker-compose安装/</id>
    <published>2019-10-28T03:55:12.773Z</published>
    <updated>2019-10-28T04:22:16.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>使用 Docker Compose 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker 的应用程序工具</li><li>安装分为两种方式，一种是使用pip安装，一种是手工安装</li></ul><a id="more"></a>    <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="手工安装方式"><a href="#手工安装方式" class="headerlink" title="手工安装方式"></a>手工安装方式</h2><ol><li><p>使用curl安装，代码如下  <code>sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose</code></p></li><li><p>使用wget安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /usr/local/bin/docker-compose https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m`</span><br></pre></td></tr></table></figure></li><li><p>安装之后可以需要赋予运行权限<code>sudo chmod +x /usr/local/bin/docker-compose</code></p></li><li><p>赋予启动权限之后需要启动一下 <code>./usr/local/bin/docker-compose</code></p></li><li><p>之后可以运行一下<code>sudo docker-compose version</code>来查看一下是否安装成功</p></li></ol><h2 id="Pip安装"><a href="#Pip安装" class="headerlink" title="Pip安装"></a>Pip安装</h2><ol><li>通过<code>pip -v</code>检查pip 是否安装及版本 </li><li><code>yum -y install epel-release</code> 安装pip基础 </li><li><code>yum install python-pip</code> 安装pip的python 支持 </li><li><code>pip install --upgrade pip</code> 完成pip的安装 </li><li><code>pip install docker-compose</code>  安装docker-compose </li></ol>]]></content>
    
    <summary type="html">
    
      docker-compose的安装安装笔记
    
    </summary>
    
    
      <category term="docker-compse" scheme="wang-jie-feng.github.io/categories/docker-compse/"/>
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="docker" scheme="wang-jie-feng.github.io/tags/docker/"/>
    
      <category term="docker-compose" scheme="wang-jie-feng.github.io/tags/docker-compose/"/>
    
  </entry>
  
  <entry>
    <title>数据结构笔记</title>
    <link href="wang-jie-feng.github.io/2019/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>wang-jie-feng.github.io/2019/10/28/数据结构/</id>
    <published>2019-10-28T01:47:49.819Z</published>
    <updated>2019-10-28T01:47:30.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ol><li>线性结构<ol><li>数组：栈</li><li>队列：链表</li><li>哈希表</li></ol></li><li>树结构<ol><li>二叉树</li><li>二分搜索树</li><li>AVL</li><li>红黑树</li><li>Treap</li><li>Splay</li><li>堆</li></ol></li><li>图结构<ol><li>邻接矩阵</li><li>邻接表</li></ol></li></ol><a id="more"></a>    <h1 id="线性结构数据结构"><a href="#线性结构数据结构" class="headerlink" title="线性结构数据结构"></a>线性结构数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li>数组基础</li><li>概念：将数据码成一排进行存放</li><li>简单的复杂度分析</li></ol><h2 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h2><ol><li>一种线性结构</li><li>相比数组，栈对应的操作是数组的子集</li><li>只能从一端添加元素，也只能从一端取出元素，称为栈顶</li><li>栈是一种后进先出的数据结构(Last In First Out)</li><li>特别适合计算机世界，拥有不可思议的作用</li><li>栈的应用<ol><li>撤销(Undo)，计算机会将操作放入栈中，记录操作，取出栈顶元素</li><li>程序调用使用的系统栈，可以保存中断的程序记录，回到上层中断的位置，继续执行程序，子过程自逻辑的调用</li></ol></li><li>栈的实现</li><li>栈的另一个应用：括号匹配</li></ol><h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><ol><li>一种线性结构</li><li>相比数组，队列对应的操作是数组的子集</li><li>只能从一端（队尾）添加元素，从另一端（队首）取出元素</li><li>类似于生活中的排队，新元素从末尾加入，从队首离开</li><li>是一种先进先出的数据结构（先到先得）（First In First Out）</li><li>循环队列<ol><li>front == tail 队列空</li><li>tail + 1 == front 队列满</li><li>循环队列复杂度比普通队列低，所以执行效率比较高</li></ol></li></ol><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol><li>真正的动态数据结构</li><li>最简单的动态数据结构</li><li>更深入的理解引用（指针）</li><li>深入理解递归</li><li>详情：<ol><li>数据存储在节点中</li><li>一部分是数据</li><li>一部分是另一个节点，即是当前一个节点的下一个节点</li></ol></li><li>优点：真正的动态，不需要处理固定容量的问题</li><li>缺点：丧失了随机访问的能力</li><li>链表的时间复杂度分析<ol><li>添加操作<ol><li>尾部 O(n)</li><li>头O(1)</li><li>任意位置O(n/2)=O(n)</li></ol></li><li>删除操作<ol><li>最后一个 O(n)</li><li>第一个 O(1)</li><li>任意一个O(n/2) = O(n)</li></ol></li><li>修改操作<ol><li>O(n)</li></ol></li><li>查找操作<ol><li>O(n)</li></ol></li></ol></li></ol><h2 id="链表和数组的对比"><a href="#链表和数组的对比" class="headerlink" title="链表和数组的对比"></a>链表和数组的对比</h2><ol><li>数组最好用于索引有语义的情况</li><li>优点：支持快速查询</li><li>链表不适合用于索引有语义的情况</li><li>优点：动态</li></ol><h2 id="链表与递归"><a href="#链表与递归" class="headerlink" title="链表与递归"></a>链表与递归</h2><ol><li>递归<ol><li>注意递归函数的“宏观语义”</li><li>递归函数就是一个函数，完成一个功能</li><li>注意不要陷入递归函数的微观，容易将自己绕迷，要从大局上把握</li><li>解决最基本的情况，分解问题，然后当做子函数调用，之后根据子函数返回的值来构建函数</li><li>递归的微观解读<ul><li>递归的调用其实就是调用一个函数，并没有任何区别</li><li>链表具有天然的递归特性</li></ul></li><li>双链表<ol><li>每一个节点同时指向前一个和后一个节点</li></ol></li><li>循环链表<ul><li>使用一个虚拟头结点</li><li>尾节点不指向null而是指向虚拟头结点</li></ul></li></ol></li></ol><h1 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h1><ol><li>树结构是一种天然的组织结构</li><li>优点<ul><li>高效，比较容易检索</li><li>使用某些数据结构后，可以更加高效，可能有一些必须使用树结构，不然无法解决</li></ul></li><li>分类<ol><li>二分搜索树</li><li>平衡二叉树(Binary Search Tree)<ul><li>AVL</li><li>红黑树</li></ul></li><li>堆</li><li>并查集</li><li>线段树</li><li>Trie（字典树，前缀树）</li></ol></li></ol><h2 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h2><ul><li>动态数据结构    </li><li>类似于链表，有两个节点，左节点和右节点</li><li>多叉树，但是绝大部分都是二叉树</li><li>二叉树具有唯一的根节点</li><li>每一个节点有两个节点，叫做左孩子，右孩子</li><li>二叉树中每个节点最多有两个孩子</li><li>一个孩子没有的节点，叫做叶子</li><li>每个节点最多有一个父亲节点，只有一个节点没有父亲节点，就是根节点</li><li>具有天然的递归结构，强调递归结构</li><li>每个节点的左右子树都是二叉树，所以天然具有递归结构</li><li>二叉树不一定是满的</li><li>二分搜索树是一个二叉树</li><li>二分搜索树每个节点的值<ul><li>大于其左子树所有的节点</li><li>小于其右子树的所有节点的值</li></ul></li><li>每一棵字数也是一个二分搜索树</li><li>存储的元素必须具有可比较性，也是一种局限性，但是这是为了提升搜索效率</li><li>删除操作<ol><li>删除最小值：左孩子一直往下到空值</li><li>删除最大值：右孩子一直往下到空值</li><li>删除任意一个值<ol><li>如果右孩子空，仅删除自己然后将左孩子和上一个连起来</li><li>如果左孩子空，仅删除自己然后将右孩子和上一个连起来</li><li>如果都不符合，那么将右孩子的最小值的左孩子设成当前节点的左孩子，右孩子设置成当前节点的右孩子，并删除当前节点<h1 id="高层数据结构"><a href="#高层数据结构" class="headerlink" title="高层数据结构"></a>高层数据结构</h1></li></ol></li></ol></li></ul><h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set)"></a>集合(set)</h2><ol><li>复杂度分析(LinkedListSet)：<ol><li>增：O(n)</li><li>查：O(n)</li><li>删：O(n)</li></ol></li><li>复杂度分析(BSTSet)：平均复杂度，即是最优情况，二分搜索树可能退化成链表那么就是和链表一样<ol><li>增：O(logn) h为二分搜索树的高度</li><li>查：O(logn)</li><li>删：O(logn)</li></ol></li><li>随着n的增大，差距越来越大</li><li>有序集合和无须集合<ol><li>二分搜索树之类是有序的-&gt;基于搜索树实现的</li><li>链表是无序的-&gt;基于哈希表实现</li></ol></li></ol><h2 id="映射-map"><a href="#映射-map" class="headerlink" title="映射(map)"></a>映射(map)</h2><ol><li>字典</li><li>键值对的数据结构</li><li>根据键来查找值</li><li>可以使用链表或者二分搜索树来实现：增加两个数据，键和值</li><li>复杂度分析</li><li>有序映射中的键具有顺序性，无序映射无序</li></ol><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><ol><li>普通队列，先进先出，后进后出，优先队列：出队顺序和入队顺序无关，和优先级相关</li><li>典型应用：<ol><li>操作系统的任务，动态选择优先级高的任务执行</li><li>不知道总量，要随时根据新来的总量来调整任务优先级</li></ol></li><li>使用队列的原因<ol><li>很多时候需要自动选择优先级高的</li></ol></li><li>使用堆操作可以将入队操作和出队操作时间复杂度做到O(logn)级别，最差的情况下是O(logn)级别</li><li>堆<ol><li>二叉堆 Binary heap</li><li>是一棵完全二叉树，如果某一次容纳不下，那么下一层从左到右来容纳节点<ol><li>最下边一层都是叶子节点</li><li>上边一层的叶子节点都在右侧</li><li>所有的节点值，都大于他的孩子值，所以根节点是最大的值</li><li>节点的大小和层次没有关系，只和自己的父节点和孩子节点的关系有关系</li><li>使用数组存储二叉堆<ol><li>左孩子 2*i</li><li>右孩子 2*i+1</li><li>parent = i/2</li></ol></li></ol></li><li>只需要计算最后一个节点的父节点，就是最后一个非叶子节点，之后对于每一个节点进行下沉操作，之后就可以讲一个数组整理成一个完全二叉树</li><li>N个元素取出前M个元素<ol><li>使用优先队列O(NLogM)</li></ol></li><li>索引堆，可以查看堆中间的数据</li><li>二项堆</li><li>斐波那契堆</li><li>广义队列<ol><li>普通队列</li><li>优先级队列</li></ol></li></ol></li></ol><h2 id="线段树（区间树）"><a href="#线段树（区间树）" class="headerlink" title="线段树（区间树）"></a>线段树（区间树）</h2><h3 id="线段树的意义"><a href="#线段树的意义" class="headerlink" title="线段树的意义"></a>线段树的意义</h3><ol><li>对于有一类的问题，我们主要关心的是一个线段，或者是一个区间</li><li>最经典的线段树问题，区间染色</li><li>区间查询</li></ol><h3 id="线段树定义"><a href="#线段树定义" class="headerlink" title="线段树定义"></a>线段树定义</h3><ol><li>线段树不是完全二叉树</li><li>线段树是平衡二叉树<ol><li>最大的深度与最小的深度相差为1</li></ol></li><li>堆也是平衡二叉树，完全二叉树一定是平衡二叉树</li></ol><h2 id="字典树-Trie"><a href="#字典树-Trie" class="headerlink" title="字典树(Trie)"></a>字典树(Trie)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>是一个多叉树</li><li>一般只用来处理字符串</li><li>查询的时候只和查询的字符串长度相关，和条目总数无关O(w)</li><li>使用的时候需要考虑不同的语言，不同的情景</li><li>数据结构<ol><li>字符和下一个的映射</li></ol></li></ol><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ol><li>孩子指向父亲</li><li>可以处理连接问题</li><li>可以非常快速判断节点中间的连接状态<ol><li>网络是抽象概念：用户之间形成的网络</li></ol></li></ol><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><ol><li>每个节点是红色的或者是黑色的</li><li>根节点是黑色的</li><li>每一个叶子节点（最后的空节点）是黑色的</li><li>如果一个节点是红色的，那么他的孩子节点都是黑色的</li><li>从任意一个节点到叶子节点，经过的黑色节点是一样的</li><li>所有红节点都是向左倾斜的</li><li>操作<ol><li>颜色反转</li><li>左旋转</li><li>右旋转</li></ol></li></ol><h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><ol><li>绝对平衡的树，从根节点都任意一个叶子的长度都是相同的</li><li>如何维持绝对平衡</li><li>使用二节点和三节点来保持绝对平衡</li></ol>]]></content>
    
    <summary type="html">
    
      对于数据结构的一点初步认识，开始学习数据结构
    
    </summary>
    
    
      <category term="数据结构" scheme="wang-jie-feng.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="wang-jie-feng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>nginx安装笔记</title>
    <link href="wang-jie-feng.github.io/2019/10/27/nginx/"/>
    <id>wang-jie-feng.github.io/2019/10/27/nginx/</id>
    <published>2019-10-26T19:20:26.202Z</published>
    <updated>2019-10-27T03:00:27.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装依赖项"><a href="#安装依赖项" class="headerlink" title="安装依赖项"></a>安装依赖项</h2><a id="more"></a><ol><li>cent<ol><li><code>yum install -y make cmake gcc gcc-c++</code></li><li><code>yum install -y pcre pcre-devel</code></li><li><code>yum install -y zlib zlib-devel</code></li><li><code>yum install -y openssl openssl-devel</code></li></ol></li><li>ubuntu<ol><li><code>sudo apt-get install build-essential</code></li><li><code>sudo apt-get install libtool</code></li><li><code>sudo apt-get install libpcre3 libpcre3-dev</code></li><li><code>sudo apt-get install zlib1g-dev</code></li><li><code>sudo apt-get install openssl</code> (默认已经安装了)</li></ol></li></ol><h2 id="通过源码安装"><a href="#通过源码安装" class="headerlink" title="通过源码安装"></a>通过源码安装</h2><ol><li>解压<ol><li><code>tar -xzvf nginxFileName -C /usr/local/nginx</code>(先创建一个nginx目录用于安装nginx)</li></ol></li><li>配置<ol><li><code>./configure --prefix=/usr/local/nginx</code></li></ol></li><li>编译<ol><li><code>make</code></li></ol></li><li>安装<ol><li><code>make install</code></li></ol></li><li>启动<ol><li><code>sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code></li><li>此处需要制定配置文件目录，不然会从默认配置文件路径读取配置</li></ol></li></ol><h2 id="通过包管理工具安装"><a href="#通过包管理工具安装" class="headerlink" title="通过包管理工具安装"></a>通过包管理工具安装</h2><ol><li>ubuntu<ol><li><code>sudo apt-get install nginx</code></li><li>通过此方式安装的软件，配置文件都在 <code>/etc/nginx</code>目录下面</li></ol></li><li>centOs<ol><li>添加<code>yum</code>源 <code>sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></li><li>安装nginx <code>sudo yum install -y nginx</code></li><li>启动nginx <code>sudo systemctl start nginx.service</code></li><li>设置开机启动<code>sudo systemctl enable nginx.service</code></li></ol></li></ol><h2 id="nginx目录结构"><a href="#nginx目录结构" class="headerlink" title="nginx目录结构"></a>nginx目录结构</h2><ol><li>网站文件默认存放目录<ol><li><code>/usr/share/nginx/html</code></li></ol></li><li>网站默认站点配置<ol><li><code>/etc/nginx/conf.d/default.conf</code></li></ol></li><li>自定义Nginx站点配置文件存放目录<ol><li><code>/etc/nginx/conf.d/</code></li></ol></li><li>nginx全局配置<ol><li><code>/etc/nginx/nginx.conf</code></li></ol></li><li>nginx启动<ol><li><code>nginx -c nginx.conf</code></li></ol></li></ol><h2 id="配置反向代理端口，做负载均衡"><a href="#配置反向代理端口，做负载均衡" class="headerlink" title="配置反向代理端口，做负载均衡"></a>配置反向代理端口，做负载均衡</h2><ol><li><p>配置两个tomcat，分别使用不同的端口</p></li><li><p>配置nginx配置文件使其代理tomcat</p><ol><li><pre><code>upstream localhost{      #Nginx是如何实现负载均衡的，Nginx的upstream目前支持以下几种方式的分配    #1、轮询（默认）    #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。    #2、weight    #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。    #2、ip_hash    #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。    #3、fair（第三方）    #按后端服务器的响应时间来分配请求，响应时间短的优先分配。    #4、url_hash（第三方）    #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。        #ip_hash;       server localhost:8080;        server localhost:8088;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.</span><br></pre></td></tr></table></figure>server {              listen       80;              server_name  localhost;                 location / {                     proxy_connect_timeout 3; #nginx跟后端服务器连接超时时间(代理连接超时)                    proxy_send_timeout 30; #后端服务器数据回传时间(代理发送超时)                    proxy_read_timeout 30; #连接成功后，后端服务器响应时间(代理接收超时)                    proxy_pass http://localhost;}</code></pre></li></ol></li><li><p>启动nginx</p><p><code>nginx -ct /usr/local/nginx/nginx1.8/conf/nginx.conf</code></p></li><li><p>访问<code>localhost</code>,可以观察到负载均衡 </p></li></ol>]]></content>
    
    <summary type="html">
    
      nginx安装笔记
    
    </summary>
    
    
      <category term="nginx" scheme="wang-jie-feng.github.io/categories/nginx/"/>
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="nginx" scheme="wang-jie-feng.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>linuxQQ发布</title>
    <link href="wang-jie-feng.github.io/2019/10/27/linuxqq/"/>
    <id>wang-jie-feng.github.io/2019/10/27/linuxqq/</id>
    <published>2019-10-26T19:20:26.199Z</published>
    <updated>2019-10-27T03:00:10.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><p>时光匆匆，随着时间流逝，已经来到了2019年，在这一年的1024程序员节这天，腾讯终于又发布了linux版的qq，说起来也是喜大普奔，作为一个程序员的我，当然马上要尝鲜一下了，接下来看一下如何安装的。</p><a id="more"></a>    <p>此次linux版的QQ分为数个版本，分别支持 <code>x64</code>，<code>ARM64</code>，<code>MIPS64</code>,三种架构，如下</p><table><thead><tr><th>架构</th><th>可支持格式</th></tr></thead><tbody><tr><td>x64</td><td>shell rpm deb pacman</td></tr><tr><td>ARM64</td><td>shell rpm deb</td></tr><tr><td>MIPS64</td><td>shell rpm</td></tr><tr><td>## 安装</td><td></td></tr></tbody></table><p>接下来看版本选择，官方提供了表格可以对照使用</p><table><thead><tr><th>后缀名</th><th>安装包管理器</th><th>支持发行版</th></tr></thead><tbody><tr><td>.rpm</td><td>rpm/yum</td><td>红帽系（如redhat、fedora、centos）</td></tr><tr><td>.deb</td><td>dpkg/apt</td><td>debian系（如debian、ubuntu、银河麒麟）</td></tr><tr><td>.pkg.tar.xz</td><td>pacman</td><td>arch系（如Arch Linux、manjaro）</td></tr><tr><td>.sh</td><td>bash</td><td>任意支持bash的发行版</td></tr></tbody></table><p>目前我使用的还是<code>ubuntu 16.04</code>，所以当然是选择使用<code>x64 deb</code>的安装方式来安装比较方便，下载完成之后</p><p>使用<code>sudo dpkg -i linuxqq_2.0.0-b1-1024_amd64.deb</code></p><p>执行完成之后即可使用，不过要吐槽的一点是目前linux版本的QQ和微信一样，也是必须使用扫码登陆，说实话还是非常不方便的，实际使用中，发现是不可以与pc版QQ可以一起登陆的。</p><h2 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h2><p>当然我也尝试了一下使用shell版本安装</p><p>首先使用 <code>sudo sh linuxqq_2.0.0-b1-1024_x86_64.sh</code></p><p>执行之后会在<code>/usr/share/</code>下建立一个<code>tencent-qq</code>的文件夹，切换进去之后执行<code>qq</code>文件即可，也可以将其加一个桌面快捷方式，可以更方便</p>]]></content>
    
    <summary type="html">
    
      linuxQQ安装
    
    </summary>
    
    
      <category term="linux" scheme="wang-jie-feng.github.io/categories/linux/"/>
    
    
      <category term="Linux" scheme="wang-jie-feng.github.io/tags/Linux/"/>
    
      <category term="qq" scheme="wang-jie-feng.github.io/tags/qq/"/>
    
  </entry>
  
</feed>
