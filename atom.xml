<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杰峰的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="wang-jie-feng.github.io/"/>
  <updated>2019-11-25T06:20:12.417Z</updated>
  <id>wang-jie-feng.github.io/</id>
  
  <author>
    <name>王杰峰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>netty入门笔记</title>
    <link href="wang-jie-feng.github.io/2019/11/25/netty%E5%85%A5%E9%97%A8/"/>
    <id>wang-jie-feng.github.io/2019/11/25/netty入门/</id>
    <published>2019-11-25T06:20:28.412Z</published>
    <updated>2019-11-25T06:20:12.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>看了netty实战这本书，记一些自己的笔记，希望自己可以进步</li></ol><a id="more"></a>    <h2 id="netty入门程序"><a href="#netty入门程序" class="headerlink" title="netty入门程序"></a>netty入门程序</h2><ol><li><p>理解一个框架最好的办法还是去使用他，使用之后肯定可以对其有了更多的理解，所以首先写一个小的demo，来看一看具体是怎么使用的</p></li><li><p>首先来写一个时间服务器，分为客户端和服务端，客户端发送一个请求，服务器端接收到请求之后返回一个时间数据，客户端将其打印出来</p></li><li><p>服务器端代码</p><p>服务器端主函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fire;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TimeServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//        用来调度，所以只需要一个</span></span><br><span class="line"><span class="comment">//        不可混用不同前缀的组件</span></span><br><span class="line">        EventLoopGroup bossGroup=<span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup=<span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b=<span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup,workerGroup)</span><br><span class="line"><span class="comment">//                    在此指定了网络响应的方式，可以使用阻塞式的也可以使用非阻塞式的</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//                            在此可以添加多个适配器，netty自己会识别是出站或是入栈适配器，确保数据只会在具有相同定向类型的适配器之间流动</span></span><br><span class="line"><span class="comment">//                            同时每个channel在创建时，会被分配一个pipiline，不可以附加另外的，也不可以分离当前的</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> TimeServerHandler());</span><br><span class="line"><span class="comment">//                            使用eventLoop的线程调度来实现自己的任务</span></span><br><span class="line">                            ch.eventLoop().scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                    System.out.println(<span class="string">"自定义任务"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;,<span class="number">10</span>,<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                            System.out.println(ch.pipeline().names());</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> TimeServer(<span class="number">9090</span>).run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fire;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.ReferenceCountUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现时间服务器具体逻辑代码</span></span><br><span class="line"><span class="comment"> * 实现的入栈适配器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次新的请求来之后，都会进行相应，ctx使得handler可以和pipeline以及其他的handler交互</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        获得一个buffer用于存储网络传输的数据，初始化最大为4，返回的是一个基于堆或者是基于直接内存的</span></span><br><span class="line"><span class="comment">//        如果当前运行的环境具有sun.misc.Unsafe支持时返回的是一个基于直接内存的，否则返回的是基于堆内存的</span></span><br><span class="line"><span class="comment">//        默认使用的api是基于池化的，所以返回的是一个引用，并不是返回的一个实例</span></span><br><span class="line"><span class="comment">//        可以使用Unpooled来获取非池化的实例，但是基于池化的性能比较强，所以一般还是使用默认的</span></span><br><span class="line">        ByteBuf time = ctx.alloc().buffer(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//        将时间写入 buffer中</span></span><br><span class="line">        time.writeInt((<span class="keyword">int</span>)(System.currentTimeMillis()/<span class="number">1000L</span>+<span class="number">2208988800L</span>));</span><br><span class="line"><span class="comment">//        将时间写入输出流，并冲刷出去，由于异步操作，此时并没有真正发送出去</span></span><br><span class="line">        ChannelFuture f = ctx.writeAndFlush(time);</span><br><span class="line"><span class="comment">//        使用future的close回调,如果成功发送，那么关闭</span></span><br><span class="line">        f.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        首先输出堆栈信息，之后关闭ctx</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    此方法为已经注册且能处理io操作时被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelRegistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    被注销且无法处理io操作时被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelUnregistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    离开活动状态，且不再连接他的远程节点时被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelInactive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    当从channel读取数据时被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        msg在此被处理，如果msg被消费或者丢弃了，那么开发者有责任将其释放资源</span></span><br><span class="line"><span class="comment">//        netty在此提供了一个简单的方法释放资源，如下代码，可以简便的释放资源</span></span><br><span class="line"><span class="comment">//        ReferenceCountUtil.release(msg);</span></span><br><span class="line">        <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    当所有可读的字节都已经从channel中读取之后，将会调用该回调方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelReadComplete(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    传入一个pojo类是被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelWritabilityChanged(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端代码</p><p>客户端主函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fire;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Bootstrap客户端用于简单建立Channel</span></span><br><span class="line">            <span class="comment">//childOption不能用于Bootstrap</span></span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(workerGroup);</span><br><span class="line">            <span class="comment">//NioSocketChannel用于客户端创建Channel</span></span><br><span class="line">            b.channel(NioSocketChannel.class);</span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">            b.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">//指定使用的数据处理方式</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> TimeClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//客户端开始连接</span></span><br><span class="line">            ChannelFuture f = b.connect(<span class="string">"localhost"</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            <span class="comment">//等待直到这个连接被关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   客户端handler</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fire;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf m=(ByteBuf)msg;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//m.readUnsignedInt获取ByteBuf当中无符号的32-bit的integer</span></span><br><span class="line">            <span class="comment">//就是我们writeInt的那个时间</span></span><br><span class="line"><span class="comment">//            获取到的是秒数，所以直接按照int读，之后自己转化为时间</span></span><br><span class="line">            <span class="keyword">long</span> currentTimeMillis = (m.readUnsignedInt() - <span class="number">2208988800L</span>) * <span class="number">1000L</span>;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date(currentTimeMillis));</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            m.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>handler是netty实现业务逻辑的地方，在此可以实现一些我们想要实现的逻辑</li></ol>]]></content>
    
    <summary type="html">
    
      对于netty的一个入门的小demo
    
    </summary>
    
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="netty" scheme="wang-jie-feng.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>git提交</title>
    <link href="wang-jie-feng.github.io/2019/11/19/git%E5%85%B3%E8%81%94%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>wang-jie-feng.github.io/2019/11/19/git关联到远程仓库/</id>
    <published>2019-11-19T07:22:14.759Z</published>
    <updated>2019-11-19T07:30:09.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>使用git时候一些小的经验</li></ul><a id="more"></a>    <h1 id="将本地工程关联到远程仓库"><a href="#将本地工程关联到远程仓库" class="headerlink" title="将本地工程关联到远程仓库"></a>将本地工程关联到远程仓库</h1><ul><li>其实非常简单，当你在github创建仓库之后就已经给了提示</li><li>步骤<ol><li>初始化本地工程 git init</li><li>将本地工程添加到暂存区 git add .</li><li>提交到本地仓库 git commit -m “first commit”</li><li>关联到远程仓库 git remote add origin  仓库地址</li><li>推送 git push -u origin master 第一次提交的时候需要加上-u参数</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      git学习笔记
    
    </summary>
    
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="git" scheme="wang-jie-feng.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>简历</title>
    <link href="wang-jie-feng.github.io/2019/11/14/%E7%8E%8B%E6%9D%B0%E5%B3%B0%E7%AE%80%E5%8E%86/"/>
    <id>wang-jie-feng.github.io/2019/11/14/王杰峰简历/</id>
    <published>2019-11-14T03:49:23.716Z</published>
    <updated>2019-11-19T07:31:37.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul><li>Email：<a href="mailto:jiefengfire@163.com" target="_blank" rel="noopener">jiefengfire@163.com</a> </li><li>手机：15518955832</li></ul><hr><a id="more"></a>    <h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li><p>王杰峰/男/1998</p></li><li><p>本科/南阳理工学院/计算机系/物联网专业</p></li><li><p>技术博客：<a href="http://wang-jie-feng.github.io">http://wang-jie-feng.github.io</a></p></li><li><p>Github： <a href="https://github.com/wang-jie-feng" target="_blank" rel="noopener">https://github.com/wang-jie-feng</a> </p></li><li><p>期望职位：Java开发工程师实习生</p></li><li><p>期望薪资：实习4-6k</p></li><li><p>期望城市：上海</p></li></ul><hr><h1 id="参与项目"><a href="#参与项目" class="headerlink" title="参与项目"></a>参与项目</h1><h2 id="javaWeb商城项目"><a href="#javaWeb商城项目" class="headerlink" title="javaWeb商城项目"></a>javaWeb商城项目</h2><ul><li>开发环境：jdk1.8/Tomcat7.0/MySql5.5/IDEA</li><li>技术架构：基于Servlet、JSP、Ajax进行开发</li><li>项目描述：系统主要实现了用户注册，登陆，退出，邮件激活账号，导航栏数据，分页查询，模糊查询，订单详情，购物车，支付宝支付，宝贝收藏等功能</li></ul><h2 id="SpringBoot项目"><a href="#SpringBoot项目" class="headerlink" title="SpringBoot项目"></a>SpringBoot项目</h2><ul><li>开发环境：jdk1.8/Tomcat7.0/maven3.5/springBoot/nginx</li><li>技术架构：基于springBoot实现</li><li>项目描述：项目开放了两个接口<ul><li>传入文件，返回访问地址</li><li>传入文件，返回md格式的图片链接</li></ul></li></ul><h2 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h2><ul><li>使用<code>Jenkins</code>结合<code>github</code>自动化部署应用</li><li>编码 → 构建 → 集成 → 测试 → 交付 → 部署 </li><li>编写脚本结合<code>Jenkins</code>实现从代码到<code>docker</code>的持续交付部署</li><li>实现过程地址： <a href="https://www.wangjiefeng.cn/2019/10/29/jendins测试/#more" target="_blank" rel="noopener">https://www.wangjiefeng.cn/2019/10/29/jendins%E6%B5%8B%E8%AF%95/#more</a> </li></ul><h2 id="目前在做-未完成…"><a href="#目前在做-未完成…" class="headerlink" title="目前在做(未完成…)"></a>目前在做(未完成…)</h2><ul><li>简介<ul><li>文件上传下载，实现文件的上传与下载</li></ul></li><li>难点<ol><li>使用对称加密与非对称加密结合方式</li><li>使用java自带数据库<code>derby</code>，使用<code>jdbc</code>原生开发</li><li>服务端使用原生<code>Servlet</code>+<code>Tomcat</code>开发,客户端使用springBoot开发</li><li>安全认证：客户端私钥签名，服务端公钥验签</li></ol></li><li>功能介绍<ol><li>文件上传服务端之后使用<code>AES</code>加密，将密钥石笋<code>RSA</code>公钥加密存储数据库中</li><li>客户端获取加密文件与加密之后的秘钥，使用<code>RSA</code>私钥解密，获取密钥将文件解密</li></ol></li></ul><hr><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><p>以下均为我熟练使用的技能</p><ul><li>Web开发：<code>java</code></li><li>Web框架：SSM/springBoot/springCloud/</li><li>前端框架：Vue</li><li>开发工具：idea/PostMan/webStorm</li><li>数据库相关：MySQL/PLSql/Oracle</li><li>版本管理、文档和自动化部署工具：Svn/Git/Jenkins</li><li>单元测试：Junit/Mock</li></ul><h1 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h1><ol><li>喜欢学习新技术，并使用它创造更好的东西</li><li>抗压能力强</li><li>完成任务效率较高</li></ol><hr><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢您花时间阅读我的简历， 期待能够得到同您面谈/面试的机会 。</p>]]></content>
    
    <summary type="html">
    
      一个进步中的java程序员，如果有工作岗位，可以联系网
    
    </summary>
    
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="简历" scheme="wang-jie-feng.github.io/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>tomcat使用笔记</title>
    <link href="wang-jie-feng.github.io/2019/11/13/%E8%A7%A3%E5%86%B3tomcat%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>wang-jie-feng.github.io/2019/11/13/解决tomcat控制台乱码问题/</id>
    <published>2019-11-13T01:45:13.859Z</published>
    <updated>2019-11-13T01:51:50.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>解决使用tomcat时，控制台输出乱码问题</p><a id="more"></a>    <ol><li><p>找到<code>apache-tomcat-8.5.46\conf\logging.properties</code></p></li><li><p>如图</p><p><img src="http://101.132.149.94:50001/33937eba-06a5-4173-887b-66a00b83331c.jpg" alt=""></p></li><li><p>将图上的UTF-8改为GBK即可</p></li></ol>]]></content>
    
    <summary type="html">
    
      解决了tomcat控制台输出乱码问题
    
    </summary>
    
    
      <category term="tomcat" scheme="wang-jie-feng.github.io/categories/tomcat/"/>
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="tomcat" scheme="wang-jie-feng.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>编程六大原则</title>
    <link href="wang-jie-feng.github.io/2019/10/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>wang-jie-feng.github.io/2019/10/31/设计模式六大原则/</id>
    <published>2019-10-31T06:15:12.684Z</published>
    <updated>2019-10-31T07:28:34.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>对于编程时六大原则的理解</li></ul><a id="more"></a>    <h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>六大原则</p><ol><li>单一职责原则(Single Responsibility Principle)</li><li>里氏替换原则(liskov substitution principle)</li><li>依赖倒置原则(dependence inversion principle)</li><li>接口隔离原则(interface segregation principle)</li><li>迪米特原则(law of demeter)</li><li>开闭原则(open closed principle)</li></ol><p>接下来就这六大原则写一些关于自己的看法</p><h3 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(Single Responsibility Principle)"></a>单一职责原则(Single Responsibility Principle)</h3><p>应该有且仅有一个原因引起类的变更（There should never be more than one reason for a class to change）。</p><p>为了达到这个目标，我们需要对于类和业务逻辑进行拆分，划分到合适的粒度， 让这些各自执行单一职责的类，各司其职。让每个类尽量行使单一的功能，实现“高内聚”，这个结果也使得类和类之间不会有过多冗余的联系，从而“低耦合”</p><p>代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">driver</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playBasketball</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打篮球"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"游泳"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个类就有一点混乱，因为这一个类里边混杂了三个职责</p><ul><li>开车：这是司机应该做的</li><li>打篮球：这是篮球运动员该做的</li><li>游泳：这是游泳运动员该做的</li></ul><p>那么，如果要遵守单一职责原则，应该怎么做呢？我们需要根据接口拆分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 司机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">driver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 篮球运动员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasketballPplayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playBasketball</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 游泳运动员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Swimmer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在People中继承这几个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Driver</span>,<span class="title">BasketballPplayer</span>,<span class="title">Swimmer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">driver</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playBasketball</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打篮球"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"游泳"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了单一职责原则，但是原则不是死的，需要在实际开发中灵活运用，允许有一定冗余。</p><h3 id="里氏替换原则-liskov-substitution-principle"><a href="#里氏替换原则-liskov-substitution-principle" class="headerlink" title="里氏替换原则(liskov substitution principle)"></a>里氏替换原则(liskov substitution principle)</h3><p> 所有引用基类的地方必须能透明地使用其子类的对象。 </p><p>换句可以更好理解的话说，就是子类必须完全实现父类的功能，凡是父类出现的地方，就算替换成子类也不会有什么问题。</p><p>标准的反例就是，如果你继承了一个类，之后你实现了类中的一个方法，可是里边什么具体代码也不写，那么就违反了里氏替换原则。这里表面上子类实现了父类的方法，但是并没有实现父类要求的逻辑。需要在代码中尽量避免这种情况。</p><p>例子</p><p>父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 认真工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 实现了父类的work方法，但是什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖倒置原则-dependence-inversion-principle"><a href="#依赖倒置原则-dependence-inversion-principle" class="headerlink" title="依赖倒置原则(dependence inversion principle)"></a>依赖倒置原则(dependence inversion principle)</h3><p>一般来说都会有三个方面来阐述</p><ul><li>高层的模块不应该依赖于低层的模块，这两者都应该依赖于其抽象</li><li>抽象不应该依赖于细节</li><li>细节应该依赖与抽象</li></ul><p>换句话说，高层次的类不应该依赖于或者说耦合与低层次的类，相反这两者都需要通过相关的接口去实现，而不是面向实现编程，所以编程的时候并不是按照我们逻辑思维思考的“依赖关系”去编程的，所以叫做依赖倒置。</p><p>改造前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层模块1:开发者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">develop</span> <span class="params">(Linux linux)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"开发者正在%s系统上进行开发%n"</span>,linux.getSystemName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 底层模块2:Linux操作系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Linux</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Linux</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSystemName</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高层模块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args [])</span> </span>&#123;</span><br><span class="line">        Coder coder = <span class="keyword">new</span> Coder();</span><br><span class="line">        Linux ubuntu = <span class="keyword">new</span> Linux(<span class="string">"ubuntu系统"</span>); </span><br><span class="line">        coder.develop(ubuntu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序员接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Programmer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">develop</span> <span class="params">(OperatingSystem OS)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 操作系统接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OperatingSystem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSystemName</span> <span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 低层模块：Linux操作系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Linux</span> <span class="keyword">implements</span>  <span class="title">OperatingSystem</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Linux</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSystemName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 低层模块：Window操作系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">OperatingSystem</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Window</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSystemName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 低层模块：开发者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> <span class="keyword">implements</span> <span class="title">Programmer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">develop</span><span class="params">(OperatingSystem OS)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"开发者正在%s系统上进行开发%n"</span>,OS.getSystemName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高层模块：测试用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args [])</span> </span>&#123;</span><br><span class="line">        Programmer coder = <span class="keyword">new</span> Coder();</span><br><span class="line">        OperatingSystem ubuntu = <span class="keyword">new</span> Linux(<span class="string">"ubuntu系统"</span>); <span class="comment">// ubuntu是一种linux操作系统</span></span><br><span class="line">        OperatingSystem windows10 = <span class="keyword">new</span> Window(<span class="string">"windows10系统"</span>); <span class="comment">// windows10</span></span><br><span class="line">        coder.develop(ubuntu);</span><br><span class="line">        coder.develop(windows10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，改造之后，虽然代码多了一些，但是可扩展性增加了非常多，即是有新的需求加入，也可以处理</p><h3 id="接口隔离原则-interface-segregation-principle"><a href="#接口隔离原则-interface-segregation-principle" class="headerlink" title="接口隔离原则(interface segregation principle)"></a>接口隔离原则(interface segregation principle)</h3><p>接口隔离的要求是：类之间的依赖关系应该建立在最小的接口上，主要分为了两点</p><ul><li>接口要足够细化，当然了，这会让接口的数量变多，但是每个接口会具有更加明确的功能 </li><li>在1的前提下，类应该依赖于“最小”的接口上 </li></ul><p>比如，现在有一大袋子吃的，但是全拿起来你是拿不动的，这时候我们就可以从里边将我们喜欢吃的拿出来，这样既满足了我们的需要，可以带走非常轻巧</p><p>备注：其实有时候单一职责原则和接口隔离原则是会互相冲突的，单一职责希望我们划分的粒度正好合适，不能多也不能少，接口隔离原则希望我们将粒度划分的尽可能小，如果出现这种情况，优先遵循单一职责原则</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 努力工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">workHard</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 消极工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NegativeWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们只想要努力工作这个需求，所以我们可以将这接口细分一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GoodWorker</span></span>&#123;</span><br><span class="line">    <span class="comment">//努力工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">workHard</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BadWorker</span></span>&#123;</span><br><span class="line">    <span class="comment">// 消极工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NegativeWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时就可以划分一个合理的范围</p><h3 id="迪米特原则-law-of-demeter"><a href="#迪米特原则-law-of-demeter" class="headerlink" title="迪米特原则(law of demeter)"></a>迪米特原则(law of demeter)</h3><p>迪米特原则还有一个名字叫做“少知道原则”，一个对象接触到的其他对象应该尽可能少，也即类和类之间的耦合度要低。</p><p>具体原则是</p><ul><li>一个类只和朋友类交流，朋友类指的是出现在成员变量、方法的输入输出参数中的类 </li><li>一个类不和陌生类交流，即没有出现在成员变量、方法的输入输出参数中的类 </li></ul><h3 id="开闭原则-open-closed-principle"><a href="#开闭原则-open-closed-principle" class="headerlink" title="开闭原则(open closed principle)"></a>开闭原则(open closed principle)</h3><p>开闭原则的意思是，软件架构要：对修改封闭，对扩展开放</p><p>比如我们使用一个软件，本来有一套我们已经使用的非常熟练的快捷键，用起来非常舒服，一天软件更新了，增加了一个快捷键实现了一个非常棒的功能，那么我们肯定非常开心</p><p>这就是增加了扩展，即对扩展开放</p><p>但是如果一次更新之后所有的快捷键都换位了，那么我们就直接抓狂了</p><p>所以我们希望已有的结构不要动，也不能动这就是“对修改封闭”</p>]]></content>
    
    <summary type="html">
    
      对于编程的六大原则的学习，探索
    
    </summary>
    
    
      <category term="六大原则" scheme="wang-jie-feng.github.io/categories/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="java" scheme="wang-jie-feng.github.io/tags/java/"/>
    
      <category term="编程" scheme="wang-jie-feng.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="六大原则" scheme="wang-jie-feng.github.io/tags/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>jenkins的测试</title>
    <link href="wang-jie-feng.github.io/2019/10/29/jendins%E6%B5%8B%E8%AF%95/"/>
    <id>wang-jie-feng.github.io/2019/10/29/jendins测试/</id>
    <published>2019-10-29T02:45:59.837Z</published>
    <updated>2019-10-29T09:31:35.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>jenkins在上一个帖子里边安装好了，那么肯定需要测试一下了，所以用一个小demo来测试一下如何使用</li></ul><a id="more"></a>    <h2 id="配置免密登陆"><a href="#配置免密登陆" class="headerlink" title="配置免密登陆"></a>配置免密登陆</h2><p>首先我们需要从使用git拉取代码，所以我们需要先配置一下ssh的免密登陆，这个需要之前安装好那个插件，如果之前没有安装那么可以现在安装一下</p><p>配置ssh密钥和和使用Git配置ssh密钥的时候没有什么差别</p><ol><li><p>进入docker运行bash</p><p><code>docker exec -id jenkins /bin/bash</code></p></li><li><p>生成ssh密钥</p><p><code>ssh-keygen -t rsa -C &quot;your_name@example.com&quot;</code></p></li><li><p>查看公钥</p><p><code>cat /var/jenkins_home/.ssh/id_rsa.pub</code></p></li><li><p>查看之后就直接将其复制然后添加到你的github里边就可以了</p></li><li><p>之后要先clone一个项目，获取到<code>known_hosts</code>文件</p></li></ol><h2 id="配置远程部署的主机"><a href="#配置远程部署的主机" class="headerlink" title="配置远程部署的主机"></a>配置远程部署的主机</h2><p><code>系统管理--&gt;系统设置--&gt;Publish over SSH</code></p><ol><li><p>点击新增填入，打了马赛克的都得填</p><p><img src="http://101.132.149.94:50001/313e04a6-c3c3-4984-822e-9b9d8cacfde3.jpg" alt=""></p></li><li><p>最后右下角的测试，测试一下是否可以连接</p></li><li><p>保存</p></li></ol><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><h3 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h3><ol><li><p>创建一个maven项目</p><p><img src="http://101.132.149.94:50001/a1b3c872-4a8f-476f-91fd-c0cb4bcd6b37.jpg" alt=""></p></li><li><p>构建项目</p><p><img src="http://101.132.149.94:50001/fb9a0916-201d-4b35-8737-ae6a89ff99ee.jpg" alt=""></p><p><img src="http://101.132.149.94:50001/6ade5114-5eb3-4588-a3d5-483f2aba860b.jpg" alt=""></p></li></ol><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p><img src="http://101.132.149.94:50001/c11701bc-e651-49b9-8c29-768a1f04cce5.jpg" alt=""></p><p><img src="http://101.132.149.94:50001/5799a39e-9ad8-415a-bfdf-6c6613fe1174.jpg" alt=""></p><p>经过这些步骤，jenkins会将代码构建到docker的工作空间里去所以我们应该加一个构建后操作，</p><p><img src="http://101.132.149.94:50001/f2f7b0aa-aa5c-4b6c-99d8-a985a346f813.jpg" alt=""></p><p>如果，这样就会将打包好的应用部署到目标服务器上</p>]]></content>
    
    <summary type="html">
    
      jenkins安装之后，测试一下
    
    </summary>
    
    
      <category term="jenkins" scheme="wang-jie-feng.github.io/categories/jenkins/"/>
    
    
      <category term="docker" scheme="wang-jie-feng.github.io/tags/docker/"/>
    
      <category term="jenkins" scheme="wang-jie-feng.github.io/tags/jenkins/"/>
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="测试" scheme="wang-jie-feng.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>图床服务器搭建</title>
    <link href="wang-jie-feng.github.io/2019/10/28/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/"/>
    <id>wang-jie-feng.github.io/2019/10/28/搭建自己的图床/</id>
    <published>2019-10-28T10:32:44.455Z</published>
    <updated>2019-10-29T02:44:11.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>图床就是放置图片的地方，对于使用hexo等搭建的静态页面博客来说，一个图床必不可少，但是对于开发者来说，市面上的图床很多存在各种限制，用起来不是很舒服，所以搭建一个自己的图床还是必不可少的</li><li>搭建一个图床并没有想象中的那么困难，而且可以锻炼自己的能力，一举多得</li></ul><a id="more"></a>    <h2 id="安装前的准备"><a href="#安装前的准备" class="headerlink" title="安装前的准备"></a>安装前的准备</h2><ol><li>一台阿里云服务器</li><li>需要安装的软件<ol><li>nginx</li></ol></li></ol><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>首先需要安装nginx，在此nginx的作用是对于图片资源的映射，使我们可以直接访问到图片资源</p><h4 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h4><ol><li><p>添加源，</p><p>默认情况下Centos7中并没有nginx的源，但是nginx提供了可以供centos7使用的源，所以可以添加一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure></li><li><p>安装nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure></li><li><p>启动nginx并设置开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx.service</span><br><span class="line">sudo systemctl enable nginx.service</span><br></pre></td></tr></table></figure></li><li><p>在浏览器中输入你的服务器地址，即可看到此图片，则安装成功</p><p><img src="http://101.132.149.94:50001/9733ad1c-336d-4c8f-8cf9-d53cce38bbb5.jpg" alt=""></p></li></ol><h4 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h4><p>安装完成之后需要配置一下，设置图片文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"># 设置监听的端口号</span><br><span class="line">        listen       50001;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"># 设置正则，配置以图片路径</span><br><span class="line">        location ~ \.(gif|jpg|jpeg|png|bmp|swf)$ &#123;</span><br><span class="line">            root /usr/local/images;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在这里使用的是50001端口，使用阿里云服务器的话，切记需要将阿里云控制台里边安全策略里边开放此端口，设置完成之后可以往里边放一个图片测试一下。</p><h2 id="Java代码部分"><a href="#Java代码部分" class="headerlink" title="Java代码部分"></a>Java代码部分</h2><p>使用nginx做完静态资源代理之后，需要写一个接口来实现图片上传并返回图片路径操作</p><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><p>待续，等我有空了在写哈哈哈哈哈哈哈哈</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>为了方便，我直接打包好了之后将jar包上传到了服务器上</p><p>使用<code>nohup java -jar fileName.jar &gt;temp.log&amp;</code>，将会以守护进程运行，temp.log将会在当前文件夹下输出日志 &gt;是覆盖式增加</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>使用postman进行调试，可以正常返回文件路径，完美</p><p><img src="http://101.132.149.94:50001/d573d5fd-134a-410a-89a4-6891d05c15c4.jpg" alt=""></p><h3 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h3><p>最好可以有一个前端页面，这样可以更好使用一些，体验更好一些…</p>]]></content>
    
    <summary type="html">
    
      使用阿里云来搭建自己的图床服务器
    
    </summary>
    
    
      <category term="图床" scheme="wang-jie-feng.github.io/categories/%E5%9B%BE%E5%BA%8A/"/>
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="nginx" scheme="wang-jie-feng.github.io/tags/nginx/"/>
    
      <category term="阿里云" scheme="wang-jie-feng.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="springboot" scheme="wang-jie-feng.github.io/tags/springboot/"/>
    
      <category term="java" scheme="wang-jie-feng.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>jenkins的安装</title>
    <link href="wang-jie-feng.github.io/2019/10/28/jendins%E5%AE%89%E8%A3%85/"/>
    <id>wang-jie-feng.github.io/2019/10/28/jendins安装/</id>
    <published>2019-10-28T06:21:34.477Z</published>
    <updated>2019-10-29T02:40:56.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>jenkins是一个个简单易用的持续集成平台，在此我使用docker的方式部署</li><li>需要主机安装docker和dockercompose，之前有可以参考一下</li></ul><a id="more"></a>    <h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><ol><li><p>docker配置文件，<code>docker-compose.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  jenkins:</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">jenkinsci/jenkins</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">jenkins</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line">      <span class="comment"># 发布端口</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">      <span class="comment"># 基于 JNLP 的 Jenkins 代理通过 TCP 端口 50000 与 Jenkins master 进行通信</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">50000</span><span class="string">:50000</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="comment"># 映射目录</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./data:/var/jenkins_home</span></span><br></pre></td></tr></table></figure></li><li><p>在和配置文件相同的文件夹下，使用<code>docker-compose up -d</code>,默认使用<code>docker-compose.yml</code></p></li><li><p>安装完成之后使用<code>docker logs jenkins</code>可获得初始密码</p></li></ol><h3 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h3><ol><li><p>打开<code>ip:8080</code>,进入jenkins控制台开始安装，在此选择<code>select plugins to install</code>，注意记得选择<code>user management and security</code>下的<code>Publish Over SSH</code></p><p><img src="http://101.132.149.94:50001/a6aac73f-ab2a-4928-8b70-3d53db518241.jpg" alt=""></p></li><li><p>点击安装，安装过程可能比较长，视个人网络环境和电脑配置而定，可以耐心等待一会，当时我安装的时候等了半个多小时还在安装，所以一定要有耐心。</p><p><img src="http://101.132.149.94:50001/a1720880-a5cc-4e17-b47c-3d8e3742130b.jpg" alt=""></p></li><li><p>有些插件可能安装失败，不过不用担心，可以之后手动安装。</p></li></ol><h3 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h3><ol><li>安装成功之后需要创建第一个管理员用户，按照提示完成即可</li></ol><h3 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>首先将jdk和maven的安装包上传到data目录里边，这是jenkins容器映射的目录，然后进入容器<code>docker exec -it jenkins /bin/bash</code>,进入<code>/var/jenkins_home</code>目录，记录下jdk和maven目录</p><ol><li><p>配置jdk</p><p>如图</p><p><img src="http://101.132.149.94:50001/b8e026a9-5b96-41bd-a4da-c4dfde871215.jpg" alt=""></p></li><li><p>配置maven</p><p>如图</p><p><img src="http://101.132.149.94:50001/585cc0b1-8870-4c76-991c-2ba68ecd18e1.jpg" alt=""></p></li><li><p>安装动态参数插件</p><p><code>系统管理--&gt;插件管理--&gt;可选插件--&gt;</code></p><p><img src="http://101.132.149.94:50001/6042783b-211c-4fb2-9f12-9a9bfd5f5dc9.jpg" alt=""></p></li><li><p>之后需要重启docker</p><p><code>docker-compose down</code></p><p><code>docker -compose up -d</code></p><p>安装成功</p><p><img src="http://101.132.149.94:50001/cf6ecc12-2d02-4595-9315-1b7673a78502.jpg" alt=""></p></li></ol><h3 id="安装结束"><a href="#安装结束" class="headerlink" title="安装结束"></a>安装结束</h3><pre><code>至此，差不多安装结束了，可以直接使用了</code></pre>]]></content>
    
    <summary type="html">
    
      jenkins的安装笔记
    
    </summary>
    
    
      <category term="jenkins" scheme="wang-jie-feng.github.io/categories/jenkins/"/>
    
    
      <category term="docker" scheme="wang-jie-feng.github.io/tags/docker/"/>
    
      <category term="jenkins" scheme="wang-jie-feng.github.io/tags/jenkins/"/>
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose的安装</title>
    <link href="wang-jie-feng.github.io/2019/10/28/docker-compose%E5%AE%89%E8%A3%85/"/>
    <id>wang-jie-feng.github.io/2019/10/28/docker-compose安装/</id>
    <published>2019-10-28T03:55:12.773Z</published>
    <updated>2019-10-28T04:22:16.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>使用 Docker Compose 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker 的应用程序工具</li><li>安装分为两种方式，一种是使用pip安装，一种是手工安装</li></ul><a id="more"></a>    <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="手工安装方式"><a href="#手工安装方式" class="headerlink" title="手工安装方式"></a>手工安装方式</h2><ol><li><p>使用curl安装，代码如下  <code>sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose</code></p></li><li><p>使用wget安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /usr/local/bin/docker-compose https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m`</span><br></pre></td></tr></table></figure></li><li><p>安装之后可以需要赋予运行权限<code>sudo chmod +x /usr/local/bin/docker-compose</code></p></li><li><p>赋予启动权限之后需要启动一下 <code>./usr/local/bin/docker-compose</code></p></li><li><p>之后可以运行一下<code>sudo docker-compose version</code>来查看一下是否安装成功</p></li></ol><h2 id="Pip安装"><a href="#Pip安装" class="headerlink" title="Pip安装"></a>Pip安装</h2><ol><li>通过<code>pip -v</code>检查pip 是否安装及版本 </li><li><code>yum -y install epel-release</code> 安装pip基础 </li><li><code>yum install python-pip</code> 安装pip的python 支持 </li><li><code>pip install --upgrade pip</code> 完成pip的安装 </li><li><code>pip install docker-compose</code>  安装docker-compose </li></ol>]]></content>
    
    <summary type="html">
    
      docker-compose的安装安装笔记
    
    </summary>
    
    
      <category term="docker-compse" scheme="wang-jie-feng.github.io/categories/docker-compse/"/>
    
    
      <category term="docker" scheme="wang-jie-feng.github.io/tags/docker/"/>
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="docker-compose" scheme="wang-jie-feng.github.io/tags/docker-compose/"/>
    
  </entry>
  
  <entry>
    <title>数据结构笔记</title>
    <link href="wang-jie-feng.github.io/2019/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>wang-jie-feng.github.io/2019/10/28/数据结构/</id>
    <published>2019-10-28T01:47:49.819Z</published>
    <updated>2019-10-28T01:47:30.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ol><li>线性结构<ol><li>数组：栈</li><li>队列：链表</li><li>哈希表</li></ol></li><li>树结构<ol><li>二叉树</li><li>二分搜索树</li><li>AVL</li><li>红黑树</li><li>Treap</li><li>Splay</li><li>堆</li></ol></li><li>图结构<ol><li>邻接矩阵</li><li>邻接表</li></ol></li></ol><a id="more"></a>    <h1 id="线性结构数据结构"><a href="#线性结构数据结构" class="headerlink" title="线性结构数据结构"></a>线性结构数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li>数组基础</li><li>概念：将数据码成一排进行存放</li><li>简单的复杂度分析</li></ol><h2 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h2><ol><li>一种线性结构</li><li>相比数组，栈对应的操作是数组的子集</li><li>只能从一端添加元素，也只能从一端取出元素，称为栈顶</li><li>栈是一种后进先出的数据结构(Last In First Out)</li><li>特别适合计算机世界，拥有不可思议的作用</li><li>栈的应用<ol><li>撤销(Undo)，计算机会将操作放入栈中，记录操作，取出栈顶元素</li><li>程序调用使用的系统栈，可以保存中断的程序记录，回到上层中断的位置，继续执行程序，子过程自逻辑的调用</li></ol></li><li>栈的实现</li><li>栈的另一个应用：括号匹配</li></ol><h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><ol><li>一种线性结构</li><li>相比数组，队列对应的操作是数组的子集</li><li>只能从一端（队尾）添加元素，从另一端（队首）取出元素</li><li>类似于生活中的排队，新元素从末尾加入，从队首离开</li><li>是一种先进先出的数据结构（先到先得）（First In First Out）</li><li>循环队列<ol><li>front == tail 队列空</li><li>tail + 1 == front 队列满</li><li>循环队列复杂度比普通队列低，所以执行效率比较高</li></ol></li></ol><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol><li>真正的动态数据结构</li><li>最简单的动态数据结构</li><li>更深入的理解引用（指针）</li><li>深入理解递归</li><li>详情：<ol><li>数据存储在节点中</li><li>一部分是数据</li><li>一部分是另一个节点，即是当前一个节点的下一个节点</li></ol></li><li>优点：真正的动态，不需要处理固定容量的问题</li><li>缺点：丧失了随机访问的能力</li><li>链表的时间复杂度分析<ol><li>添加操作<ol><li>尾部 O(n)</li><li>头O(1)</li><li>任意位置O(n/2)=O(n)</li></ol></li><li>删除操作<ol><li>最后一个 O(n)</li><li>第一个 O(1)</li><li>任意一个O(n/2) = O(n)</li></ol></li><li>修改操作<ol><li>O(n)</li></ol></li><li>查找操作<ol><li>O(n)</li></ol></li></ol></li></ol><h2 id="链表和数组的对比"><a href="#链表和数组的对比" class="headerlink" title="链表和数组的对比"></a>链表和数组的对比</h2><ol><li>数组最好用于索引有语义的情况</li><li>优点：支持快速查询</li><li>链表不适合用于索引有语义的情况</li><li>优点：动态</li></ol><h2 id="链表与递归"><a href="#链表与递归" class="headerlink" title="链表与递归"></a>链表与递归</h2><ol><li>递归<ol><li>注意递归函数的“宏观语义”</li><li>递归函数就是一个函数，完成一个功能</li><li>注意不要陷入递归函数的微观，容易将自己绕迷，要从大局上把握</li><li>解决最基本的情况，分解问题，然后当做子函数调用，之后根据子函数返回的值来构建函数</li><li>递归的微观解读<ul><li>递归的调用其实就是调用一个函数，并没有任何区别</li><li>链表具有天然的递归特性</li></ul></li><li>双链表<ol><li>每一个节点同时指向前一个和后一个节点</li></ol></li><li>循环链表<ul><li>使用一个虚拟头结点</li><li>尾节点不指向null而是指向虚拟头结点</li></ul></li></ol></li></ol><h1 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h1><ol><li>树结构是一种天然的组织结构</li><li>优点<ul><li>高效，比较容易检索</li><li>使用某些数据结构后，可以更加高效，可能有一些必须使用树结构，不然无法解决</li></ul></li><li>分类<ol><li>二分搜索树</li><li>平衡二叉树(Binary Search Tree)<ul><li>AVL</li><li>红黑树</li></ul></li><li>堆</li><li>并查集</li><li>线段树</li><li>Trie（字典树，前缀树）</li></ol></li></ol><h2 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h2><ul><li>动态数据结构    </li><li>类似于链表，有两个节点，左节点和右节点</li><li>多叉树，但是绝大部分都是二叉树</li><li>二叉树具有唯一的根节点</li><li>每一个节点有两个节点，叫做左孩子，右孩子</li><li>二叉树中每个节点最多有两个孩子</li><li>一个孩子没有的节点，叫做叶子</li><li>每个节点最多有一个父亲节点，只有一个节点没有父亲节点，就是根节点</li><li>具有天然的递归结构，强调递归结构</li><li>每个节点的左右子树都是二叉树，所以天然具有递归结构</li><li>二叉树不一定是满的</li><li>二分搜索树是一个二叉树</li><li>二分搜索树每个节点的值<ul><li>大于其左子树所有的节点</li><li>小于其右子树的所有节点的值</li></ul></li><li>每一棵字数也是一个二分搜索树</li><li>存储的元素必须具有可比较性，也是一种局限性，但是这是为了提升搜索效率</li><li>删除操作<ol><li>删除最小值：左孩子一直往下到空值</li><li>删除最大值：右孩子一直往下到空值</li><li>删除任意一个值<ol><li>如果右孩子空，仅删除自己然后将左孩子和上一个连起来</li><li>如果左孩子空，仅删除自己然后将右孩子和上一个连起来</li><li>如果都不符合，那么将右孩子的最小值的左孩子设成当前节点的左孩子，右孩子设置成当前节点的右孩子，并删除当前节点<h1 id="高层数据结构"><a href="#高层数据结构" class="headerlink" title="高层数据结构"></a>高层数据结构</h1></li></ol></li></ol></li></ul><h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set)"></a>集合(set)</h2><ol><li>复杂度分析(LinkedListSet)：<ol><li>增：O(n)</li><li>查：O(n)</li><li>删：O(n)</li></ol></li><li>复杂度分析(BSTSet)：平均复杂度，即是最优情况，二分搜索树可能退化成链表那么就是和链表一样<ol><li>增：O(logn) h为二分搜索树的高度</li><li>查：O(logn)</li><li>删：O(logn)</li></ol></li><li>随着n的增大，差距越来越大</li><li>有序集合和无须集合<ol><li>二分搜索树之类是有序的-&gt;基于搜索树实现的</li><li>链表是无序的-&gt;基于哈希表实现</li></ol></li></ol><h2 id="映射-map"><a href="#映射-map" class="headerlink" title="映射(map)"></a>映射(map)</h2><ol><li>字典</li><li>键值对的数据结构</li><li>根据键来查找值</li><li>可以使用链表或者二分搜索树来实现：增加两个数据，键和值</li><li>复杂度分析</li><li>有序映射中的键具有顺序性，无序映射无序</li></ol><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><ol><li>普通队列，先进先出，后进后出，优先队列：出队顺序和入队顺序无关，和优先级相关</li><li>典型应用：<ol><li>操作系统的任务，动态选择优先级高的任务执行</li><li>不知道总量，要随时根据新来的总量来调整任务优先级</li></ol></li><li>使用队列的原因<ol><li>很多时候需要自动选择优先级高的</li></ol></li><li>使用堆操作可以将入队操作和出队操作时间复杂度做到O(logn)级别，最差的情况下是O(logn)级别</li><li>堆<ol><li>二叉堆 Binary heap</li><li>是一棵完全二叉树，如果某一次容纳不下，那么下一层从左到右来容纳节点<ol><li>最下边一层都是叶子节点</li><li>上边一层的叶子节点都在右侧</li><li>所有的节点值，都大于他的孩子值，所以根节点是最大的值</li><li>节点的大小和层次没有关系，只和自己的父节点和孩子节点的关系有关系</li><li>使用数组存储二叉堆<ol><li>左孩子 2*i</li><li>右孩子 2*i+1</li><li>parent = i/2</li></ol></li></ol></li><li>只需要计算最后一个节点的父节点，就是最后一个非叶子节点，之后对于每一个节点进行下沉操作，之后就可以讲一个数组整理成一个完全二叉树</li><li>N个元素取出前M个元素<ol><li>使用优先队列O(NLogM)</li></ol></li><li>索引堆，可以查看堆中间的数据</li><li>二项堆</li><li>斐波那契堆</li><li>广义队列<ol><li>普通队列</li><li>优先级队列</li></ol></li></ol></li></ol><h2 id="线段树（区间树）"><a href="#线段树（区间树）" class="headerlink" title="线段树（区间树）"></a>线段树（区间树）</h2><h3 id="线段树的意义"><a href="#线段树的意义" class="headerlink" title="线段树的意义"></a>线段树的意义</h3><ol><li>对于有一类的问题，我们主要关心的是一个线段，或者是一个区间</li><li>最经典的线段树问题，区间染色</li><li>区间查询</li></ol><h3 id="线段树定义"><a href="#线段树定义" class="headerlink" title="线段树定义"></a>线段树定义</h3><ol><li>线段树不是完全二叉树</li><li>线段树是平衡二叉树<ol><li>最大的深度与最小的深度相差为1</li></ol></li><li>堆也是平衡二叉树，完全二叉树一定是平衡二叉树</li></ol><h2 id="字典树-Trie"><a href="#字典树-Trie" class="headerlink" title="字典树(Trie)"></a>字典树(Trie)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>是一个多叉树</li><li>一般只用来处理字符串</li><li>查询的时候只和查询的字符串长度相关，和条目总数无关O(w)</li><li>使用的时候需要考虑不同的语言，不同的情景</li><li>数据结构<ol><li>字符和下一个的映射</li></ol></li></ol><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ol><li>孩子指向父亲</li><li>可以处理连接问题</li><li>可以非常快速判断节点中间的连接状态<ol><li>网络是抽象概念：用户之间形成的网络</li></ol></li></ol><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><ol><li>每个节点是红色的或者是黑色的</li><li>根节点是黑色的</li><li>每一个叶子节点（最后的空节点）是黑色的</li><li>如果一个节点是红色的，那么他的孩子节点都是黑色的</li><li>从任意一个节点到叶子节点，经过的黑色节点是一样的</li><li>所有红节点都是向左倾斜的</li><li>操作<ol><li>颜色反转</li><li>左旋转</li><li>右旋转</li></ol></li></ol><h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><ol><li>绝对平衡的树，从根节点都任意一个叶子的长度都是相同的</li><li>如何维持绝对平衡</li><li>使用二节点和三节点来保持绝对平衡</li></ol>]]></content>
    
    <summary type="html">
    
      对于数据结构的一点初步认识，开始学习数据结构
    
    </summary>
    
    
      <category term="数据结构" scheme="wang-jie-feng.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="wang-jie-feng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>nginx安装笔记</title>
    <link href="wang-jie-feng.github.io/2019/10/27/nginx/"/>
    <id>wang-jie-feng.github.io/2019/10/27/nginx/</id>
    <published>2019-10-26T19:20:26.202Z</published>
    <updated>2019-10-27T03:00:27.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装依赖项"><a href="#安装依赖项" class="headerlink" title="安装依赖项"></a>安装依赖项</h2><a id="more"></a><ol><li>cent<ol><li><code>yum install -y make cmake gcc gcc-c++</code></li><li><code>yum install -y pcre pcre-devel</code></li><li><code>yum install -y zlib zlib-devel</code></li><li><code>yum install -y openssl openssl-devel</code></li></ol></li><li>ubuntu<ol><li><code>sudo apt-get install build-essential</code></li><li><code>sudo apt-get install libtool</code></li><li><code>sudo apt-get install libpcre3 libpcre3-dev</code></li><li><code>sudo apt-get install zlib1g-dev</code></li><li><code>sudo apt-get install openssl</code> (默认已经安装了)</li></ol></li></ol><h2 id="通过源码安装"><a href="#通过源码安装" class="headerlink" title="通过源码安装"></a>通过源码安装</h2><ol><li>解压<ol><li><code>tar -xzvf nginxFileName -C /usr/local/nginx</code>(先创建一个nginx目录用于安装nginx)</li></ol></li><li>配置<ol><li><code>./configure --prefix=/usr/local/nginx</code></li></ol></li><li>编译<ol><li><code>make</code></li></ol></li><li>安装<ol><li><code>make install</code></li></ol></li><li>启动<ol><li><code>sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code></li><li>此处需要制定配置文件目录，不然会从默认配置文件路径读取配置</li></ol></li></ol><h2 id="通过包管理工具安装"><a href="#通过包管理工具安装" class="headerlink" title="通过包管理工具安装"></a>通过包管理工具安装</h2><ol><li>ubuntu<ol><li><code>sudo apt-get install nginx</code></li><li>通过此方式安装的软件，配置文件都在 <code>/etc/nginx</code>目录下面</li></ol></li><li>centOs<ol><li>添加<code>yum</code>源 <code>sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></li><li>安装nginx <code>sudo yum install -y nginx</code></li><li>启动nginx <code>sudo systemctl start nginx.service</code></li><li>设置开机启动<code>sudo systemctl enable nginx.service</code></li></ol></li></ol><h2 id="nginx目录结构"><a href="#nginx目录结构" class="headerlink" title="nginx目录结构"></a>nginx目录结构</h2><ol><li>网站文件默认存放目录<ol><li><code>/usr/share/nginx/html</code></li></ol></li><li>网站默认站点配置<ol><li><code>/etc/nginx/conf.d/default.conf</code></li></ol></li><li>自定义Nginx站点配置文件存放目录<ol><li><code>/etc/nginx/conf.d/</code></li></ol></li><li>nginx全局配置<ol><li><code>/etc/nginx/nginx.conf</code></li></ol></li><li>nginx启动<ol><li><code>nginx -c nginx.conf</code></li></ol></li></ol><h2 id="配置反向代理端口，做负载均衡"><a href="#配置反向代理端口，做负载均衡" class="headerlink" title="配置反向代理端口，做负载均衡"></a>配置反向代理端口，做负载均衡</h2><ol><li><p>配置两个tomcat，分别使用不同的端口</p></li><li><p>配置nginx配置文件使其代理tomcat</p><ol><li><pre><code>upstream localhost{      #Nginx是如何实现负载均衡的，Nginx的upstream目前支持以下几种方式的分配    #1、轮询（默认）    #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。    #2、weight    #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。    #2、ip_hash    #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。    #3、fair（第三方）    #按后端服务器的响应时间来分配请求，响应时间短的优先分配。    #4、url_hash（第三方）    #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。        #ip_hash;       server localhost:8080;        server localhost:8088;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.</span><br></pre></td></tr></table></figure>server {              listen       80;              server_name  localhost;                 location / {                     proxy_connect_timeout 3; #nginx跟后端服务器连接超时时间(代理连接超时)                    proxy_send_timeout 30; #后端服务器数据回传时间(代理发送超时)                    proxy_read_timeout 30; #连接成功后，后端服务器响应时间(代理接收超时)                    proxy_pass http://localhost;}</code></pre></li></ol></li><li><p>启动nginx</p><p><code>nginx -ct /usr/local/nginx/nginx1.8/conf/nginx.conf</code></p></li><li><p>访问<code>localhost</code>,可以观察到负载均衡 </p></li></ol>]]></content>
    
    <summary type="html">
    
      nginx安装笔记
    
    </summary>
    
    
      <category term="nginx" scheme="wang-jie-feng.github.io/categories/nginx/"/>
    
    
      <category term="笔记" scheme="wang-jie-feng.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="nginx" scheme="wang-jie-feng.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>linuxQQ发布</title>
    <link href="wang-jie-feng.github.io/2019/10/27/linuxqq/"/>
    <id>wang-jie-feng.github.io/2019/10/27/linuxqq/</id>
    <published>2019-10-26T19:20:26.199Z</published>
    <updated>2019-10-27T03:00:10.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><p>时光匆匆，随着时间流逝，已经来到了2019年，在这一年的1024程序员节这天，腾讯终于又发布了linux版的qq，说起来也是喜大普奔，作为一个程序员的我，当然马上要尝鲜一下了，接下来看一下如何安装的。</p><a id="more"></a>    <p>此次linux版的QQ分为数个版本，分别支持 <code>x64</code>，<code>ARM64</code>，<code>MIPS64</code>,三种架构，如下</p><table><thead><tr><th>架构</th><th>可支持格式</th></tr></thead><tbody><tr><td>x64</td><td>shell rpm deb pacman</td></tr><tr><td>ARM64</td><td>shell rpm deb</td></tr><tr><td>MIPS64</td><td>shell rpm</td></tr><tr><td>## 安装</td><td></td></tr></tbody></table><p>接下来看版本选择，官方提供了表格可以对照使用</p><table><thead><tr><th>后缀名</th><th>安装包管理器</th><th>支持发行版</th></tr></thead><tbody><tr><td>.rpm</td><td>rpm/yum</td><td>红帽系（如redhat、fedora、centos）</td></tr><tr><td>.deb</td><td>dpkg/apt</td><td>debian系（如debian、ubuntu、银河麒麟）</td></tr><tr><td>.pkg.tar.xz</td><td>pacman</td><td>arch系（如Arch Linux、manjaro）</td></tr><tr><td>.sh</td><td>bash</td><td>任意支持bash的发行版</td></tr></tbody></table><p>目前我使用的还是<code>ubuntu 16.04</code>，所以当然是选择使用<code>x64 deb</code>的安装方式来安装比较方便，下载完成之后</p><p>使用<code>sudo dpkg -i linuxqq_2.0.0-b1-1024_amd64.deb</code></p><p>执行完成之后即可使用，不过要吐槽的一点是目前linux版本的QQ和微信一样，也是必须使用扫码登陆，说实话还是非常不方便的，实际使用中，发现是不可以与pc版QQ可以一起登陆的。</p><h2 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h2><p>当然我也尝试了一下使用shell版本安装</p><p>首先使用 <code>sudo sh linuxqq_2.0.0-b1-1024_x86_64.sh</code></p><p>执行之后会在<code>/usr/share/</code>下建立一个<code>tencent-qq</code>的文件夹，切换进去之后执行<code>qq</code>文件即可，也可以将其加一个桌面快捷方式，可以更方便</p>]]></content>
    
    <summary type="html">
    
      linuxQQ安装
    
    </summary>
    
    
      <category term="linux" scheme="wang-jie-feng.github.io/categories/linux/"/>
    
    
      <category term="Linux" scheme="wang-jie-feng.github.io/tags/Linux/"/>
    
      <category term="qq" scheme="wang-jie-feng.github.io/tags/qq/"/>
    
  </entry>
  
</feed>
